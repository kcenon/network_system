<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Network System: Technical Implementation Details</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Network System<span id="projectnumber">&#160;2.0.0</span>
   </div>
   <div id="projectbrief">High-performance modular networking library for scalable client-server applications</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">Technical Implementation Details </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md208"></a></p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md209"></a>
Network System Separation Technical Implementation Guide</h1>
<p><b>Date</b>: 2025-09-19 <b>Version</b>: 1.0.0 <b>Owner</b>: kcenon</p>
<hr  />
<h2 class="doxsection"><a class="anchor" id="autotoc_md211"></a>
🏗️ Architecture Design</h2>
<h3 class="doxsection"><a class="anchor" id="autotoc_md212"></a>
1. Module Layer Structure</h3>
<div class="fragment"><div class="line">┌─────────────────────────────────────┐</div>
<div class="line">│        Application Layer           │</div>
<div class="line">│   (messaging_system, other apps)   │</div>
<div class="line">└─────────────────┬───────────────────┘</div>
<div class="line">                  │</div>
<div class="line">┌─────────────────▼───────────────────┐</div>
<div class="line">│     Integration Layer               │</div>
<div class="line">│  ┌─────────────┬─────────────────┐  │</div>
<div class="line">│  │ messaging   │ container       │  │</div>
<div class="line">│  │ _bridge     │ _integration    │  │</div>
<div class="line">│  └─────────────┴─────────────────┘  │</div>
<div class="line">└─────────────────┬───────────────────┘</div>
<div class="line">                  │</div>
<div class="line">┌─────────────────▼───────────────────┐</div>
<div class="line">│     Network System Core             │</div>
<div class="line">│  ┌───────┬─────────┬─────────────┐  │</div>
<div class="line">│  │ Core  │ Session │ Internal    │  │</div>
<div class="line">│  │ API   │ Mgmt    │ Impl        │  │</div>
<div class="line">│  └───────┴─────────┴─────────────┘  │</div>
<div class="line">└─────────────────┬───────────────────┘</div>
<div class="line">                  │</div>
<div class="line">┌─────────────────▼───────────────────┐</div>
<div class="line">│     External Dependencies           │</div>
<div class="line">│  ASIO │ fmt │ thread_system │ etc.  │</div>
<div class="line">└─────────────────────────────────────┘</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md213"></a>
2. Namespace Design</h3>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>network_system {</div>
<div class="line">    <span class="comment">// Core API</span></div>
<div class="line">    <span class="keyword">namespace </span>core {</div>
<div class="line">        <span class="keyword">class </span>messaging_client;</div>
<div class="line">        <span class="keyword">class </span>messaging_server;</div>
<div class="line">        <span class="keyword">class </span>network_config;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Session management</span></div>
<div class="line">    <span class="keyword">namespace </span>session {</div>
<div class="line">        <span class="keyword">class </span>messaging_session;</div>
<div class="line">        <span class="keyword">class </span>session_manager;</div>
<div class="line">        <span class="keyword">class </span>connection_pool;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Internal implementation (not exposed externally)</span></div>
<div class="line">    <span class="keyword">namespace </span>internal {</div>
<div class="line">        <span class="keyword">class </span>tcp_socket;</div>
<div class="line">        <span class="keyword">class </span>send_coroutine;</div>
<div class="line">        <span class="keyword">class </span>message_pipeline;</div>
<div class="line">        <span class="keyword">class </span>protocol_handler;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// System integration</span></div>
<div class="line">    <span class="keyword">namespace </span>integration {</div>
<div class="line">        <span class="keyword">class </span>messaging_bridge;</div>
<div class="line">        <span class="keyword">class </span>container_integration;</div>
<div class="line">        <span class="keyword">class </span>thread_integration;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Compatibility namespace (for existing code)</span></div>
<div class="line">        <span class="keyword">namespace </span>compat {</div>
<div class="line">            <span class="keyword">namespace </span>network_module = network_system;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Utilities</span></div>
<div class="line">    <span class="keyword">namespace </span>utils {</div>
<div class="line">        <span class="keyword">class </span>network_utils;</div>
<div class="line">        <span class="keyword">class </span>address_resolver;</div>
<div class="line">        <span class="keyword">class </span>performance_monitor;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
<h2 class="doxsection"><a class="anchor" id="autotoc_md215"></a>
🔧 Core Component Implementation</h2>
<h3 class="doxsection"><a class="anchor" id="autotoc_md216"></a>
1. messaging_bridge Class</h3>
<div class="fragment"><div class="line"><span class="comment">// include/network_system/integration/messaging_bridge.h</span></div>
<div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;network_system/core/messaging_client.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;network_system/core/messaging_server.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;network_system/utils/performance_monitor.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef BUILD_WITH_CONTAINER_SYSTEM</span></div>
<div class="line"><span class="preprocessor">#include &quot;container_system/value_container.h&quot;</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef BUILD_WITH_THREAD_SYSTEM</span></div>
<div class="line"><span class="preprocessor">#include &quot;thread_system/thread_pool.h&quot;</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>network_system::integration {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>messaging_bridge {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Constructor/Destructor</span></div>
<div class="line">    <span class="keyword">explicit</span> messaging_bridge(<span class="keyword">const</span> std::string&amp; bridge_id = <span class="stringliteral">&quot;default&quot;</span>);</div>
<div class="line">    ~messaging_bridge();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Delete copy and move constructors (singleton pattern)</span></div>
<div class="line">    messaging_bridge(<span class="keyword">const</span> messaging_bridge&amp;) = <span class="keyword">delete</span>;</div>
<div class="line">    messaging_bridge&amp; operator=(<span class="keyword">const</span> messaging_bridge&amp;) = <span class="keyword">delete</span>;</div>
<div class="line">    messaging_bridge(messaging_bridge&amp;&amp;) = <span class="keyword">delete</span>;</div>
<div class="line">    messaging_bridge&amp; operator=(messaging_bridge&amp;&amp;) = <span class="keyword">delete</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Server/Client factory</span></div>
<div class="line">    std::shared_ptr&lt;core::messaging_server&gt; create_server(</div>
<div class="line">        <span class="keyword">const</span> std::string&amp; server_id,</div>
<div class="line">        <span class="keyword">const</span> core::server_config&amp; config = {}</div>
<div class="line">    );</div>
<div class="line"> </div>
<div class="line">    std::shared_ptr&lt;core::messaging_client&gt; create_client(</div>
<div class="line">        <span class="keyword">const</span> std::string&amp; client_id,</div>
<div class="line">        <span class="keyword">const</span> core::client_config&amp; config = {}</div>
<div class="line">    );</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Compatibility API (for existing messaging_system code)</span></div>
<div class="line">    <span class="keyword">namespace </span>compat {</div>
<div class="line">        <span class="keyword">using </span>messaging_server = core::messaging_server;</div>
<div class="line">        <span class="keyword">using </span>messaging_client = core::messaging_client;</div>
<div class="line">        <span class="keyword">using </span>messaging_session = session::messaging_session;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Same function signatures as existing ones</span></div>
<div class="line">        std::shared_ptr&lt;messaging_server&gt; make_messaging_server(</div>
<div class="line">            <span class="keyword">const</span> std::string&amp; server_id</div>
<div class="line">        );</div>
<div class="line">        std::shared_ptr&lt;messaging_client&gt; make_messaging_client(</div>
<div class="line">            <span class="keyword">const</span> std::string&amp; client_id</div>
<div class="line">        );</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef BUILD_WITH_CONTAINER_SYSTEM</span></div>
<div class="line">    <span class="comment">// Container System integration</span></div>
<div class="line">    <span class="keywordtype">void</span> set_container_factory(</div>
<div class="line">        std::shared_ptr&lt;container_system::value_factory&gt; factory</div>
<div class="line">    );</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> enable_container_serialization(<span class="keywordtype">bool</span> enable = <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> MessageHandler&gt;</div>
<div class="line">    <span class="keywordtype">void</span> set_container_message_handler(MessageHandler&amp;&amp; handler) {</div>
<div class="line">        <span class="keyword">static_assert</span>(std::is_invocable_v&lt;MessageHandler,</div>
<div class="line">            std::shared_ptr&lt;container_system::value_container&gt;&gt;,</div>
<div class="line">            <span class="stringliteral">&quot;Handler must accept std::shared_ptr&lt;container_system::value_container&gt;&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        container_message_handler_ = std::forward&lt;MessageHandler&gt;(handler);</div>
<div class="line">    }</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef BUILD_WITH_THREAD_SYSTEM</span></div>
<div class="line">    <span class="comment">// Thread System integration</span></div>
<div class="line">    <span class="keywordtype">void</span> set_thread_pool(</div>
<div class="line">        std::shared_ptr&lt;thread_system::thread_pool&gt; pool</div>
<div class="line">    );</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> set_async_mode(<span class="keywordtype">bool</span> async = <span class="keyword">true</span>);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Configuration management</span></div>
<div class="line">    <span class="keyword">struct </span>bridge_config {</div>
<div class="line">        <span class="keywordtype">bool</span> enable_performance_monitoring = <span class="keyword">true</span>;</div>
<div class="line">        <span class="keywordtype">bool</span> enable_message_logging = <span class="keyword">false</span>;</div>
<div class="line">        <span class="keywordtype">bool</span> enable_connection_pooling = <span class="keyword">true</span>;</div>
<div class="line">        <span class="keywordtype">size_t</span> max_connections_per_client = 10;</div>
<div class="line">        std::chrono::milliseconds connection_timeout{30000};</div>
<div class="line">        std::chrono::milliseconds message_timeout{5000};</div>
<div class="line">        <span class="keywordtype">size_t</span> message_buffer_size = 8192;</div>
<div class="line">        <span class="keywordtype">bool</span> enable_compression = <span class="keyword">false</span>;</div>
<div class="line">        <span class="keywordtype">bool</span> enable_encryption = <span class="keyword">false</span>;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> set_config(<span class="keyword">const</span> bridge_config&amp; config);</div>
<div class="line">    bridge_config get_config() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Performance monitoring</span></div>
<div class="line">    <span class="keyword">struct </span>performance_metrics {</div>
<div class="line">        <span class="comment">// Connection statistics</span></div>
<div class="line">        std::atomic&lt;uint64_t&gt; total_connections{0};</div>
<div class="line">        std::atomic&lt;uint64_t&gt; active_connections{0};</div>
<div class="line">        std::atomic&lt;uint64_t&gt; failed_connections{0};</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Message statistics</span></div>
<div class="line">        std::atomic&lt;uint64_t&gt; messages_sent{0};</div>
<div class="line">        std::atomic&lt;uint64_t&gt; messages_received{0};</div>
<div class="line">        std::atomic&lt;uint64_t&gt; bytes_sent{0};</div>
<div class="line">        std::atomic&lt;uint64_t&gt; bytes_received{0};</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Performance statistics</span></div>
<div class="line">        std::atomic&lt;uint64_t&gt; avg_latency_us{0};</div>
<div class="line">        std::atomic&lt;uint64_t&gt; max_latency_us{0};</div>
<div class="line">        std::atomic&lt;uint64_t&gt; min_latency_us{UINT64_MAX};</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Error statistics</span></div>
<div class="line">        std::atomic&lt;uint64_t&gt; send_errors{0};</div>
<div class="line">        std::atomic&lt;uint64_t&gt; receive_errors{0};</div>
<div class="line">        std::atomic&lt;uint64_t&gt; timeout_errors{0};</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Time information</span></div>
<div class="line">        std::chrono::steady_clock::time_point start_time;</div>
<div class="line">        std::chrono::steady_clock::time_point last_update;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    performance_metrics get_metrics() <span class="keyword">const</span>;</div>
<div class="line">    <span class="keywordtype">void</span> reset_metrics();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Event handlers</span></div>
<div class="line">    <span class="keyword">using </span>connection_event_handler = std::function&lt;void(</div>
<div class="line">        <span class="keyword">const</span> std::string&amp; endpoint, <span class="keywordtype">bool</span> connected)&gt;;</div>
<div class="line">    <span class="keyword">using </span>error_event_handler = std::function&lt;void(</div>
<div class="line">        <span class="keyword">const</span> std::string&amp; error_msg, <span class="keywordtype">int</span> error_code)&gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> set_connection_event_handler(connection_event_handler handler);</div>
<div class="line">    <span class="keywordtype">void</span> set_error_event_handler(error_event_handler handler);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Lifecycle management</span></div>
<div class="line">    <span class="keywordtype">void</span> start();</div>
<div class="line">    <span class="keywordtype">void</span> stop();</div>
<div class="line">    <span class="keywordtype">bool</span> is_running() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Debugging and diagnostics</span></div>
<div class="line">    std::string get_status_report() <span class="keyword">const</span>;</div>
<div class="line">    <span class="keywordtype">void</span> enable_debug_logging(<span class="keywordtype">bool</span> enable = <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">class </span>impl;</div>
<div class="line">    std::unique_ptr&lt;impl&gt; pimpl_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace network_system::integration</span></div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md217"></a>
2. Core API Design</h3>
<div class="fragment"><div class="line"><span class="comment">// include/network_system/core/messaging_server.h</span></div>
<div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;network_system/session/messaging_session.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;functional&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>network_system::core {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>server_config {</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> port = 8080;</div>
<div class="line">    std::string bind_address = <span class="stringliteral">&quot;0.0.0.0&quot;</span>;</div>
<div class="line">    <span class="keywordtype">size_t</span> max_connections = 1000;</div>
<div class="line">    <span class="keywordtype">size_t</span> message_size_limit = 1024 * 1024; <span class="comment">// 1MB</span></div>
<div class="line">    std::chrono::seconds timeout{30};</div>
<div class="line">    <span class="keywordtype">bool</span> enable_keep_alive = <span class="keyword">true</span>;</div>
<div class="line">    <span class="keywordtype">bool</span> enable_nodelay = <span class="keyword">true</span>;</div>
<div class="line">    <span class="keywordtype">size_t</span> receive_buffer_size = 8192;</div>
<div class="line">    <span class="keywordtype">size_t</span> send_buffer_size = 8192;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>messaging_server {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Constructor</span></div>
<div class="line">    <span class="keyword">explicit</span> messaging_server(<span class="keyword">const</span> std::string&amp; server_id);</div>
<div class="line">    messaging_server(<span class="keyword">const</span> std::string&amp; server_id, <span class="keyword">const</span> server_config&amp; config);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Destructor</span></div>
<div class="line">    ~messaging_server();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Delete copy/move</span></div>
<div class="line">    messaging_server(<span class="keyword">const</span> messaging_server&amp;) = <span class="keyword">delete</span>;</div>
<div class="line">    messaging_server&amp; operator=(<span class="keyword">const</span> messaging_server&amp;) = <span class="keyword">delete</span>;</div>
<div class="line">    messaging_server(messaging_server&amp;&amp;) = <span class="keyword">delete</span>;</div>
<div class="line">    messaging_server&amp; operator=(messaging_server&amp;&amp;) = <span class="keyword">delete</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Server lifecycle</span></div>
<div class="line">    <span class="keywordtype">bool</span> start_server();</div>
<div class="line">    <span class="keywordtype">bool</span> start_server(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> port);</div>
<div class="line">    <span class="keywordtype">bool</span> start_server(<span class="keyword">const</span> std::string&amp; bind_address, <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> port);</div>
<div class="line">    <span class="keywordtype">void</span> stop_server();</div>
<div class="line">    <span class="keywordtype">void</span> wait_for_stop();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Status queries</span></div>
<div class="line">    <span class="keywordtype">bool</span> is_running() <span class="keyword">const</span>;</div>
<div class="line">    std::string server_id() <span class="keyword">const</span>;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> port() <span class="keyword">const</span>;</div>
<div class="line">    std::string bind_address() <span class="keyword">const</span>;</div>
<div class="line">    <span class="keywordtype">size_t</span> connection_count() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Configuration management</span></div>
<div class="line">    <span class="keywordtype">void</span> set_config(<span class="keyword">const</span> server_config&amp; config);</div>
<div class="line">    server_config get_config() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Event handler setup</span></div>
<div class="line">    <span class="keyword">using </span>message_handler = std::function&lt;void(</div>
<div class="line">        std::shared_ptr&lt;session::messaging_session&gt;,</div>
<div class="line">        <span class="keyword">const</span> std::string&amp;)&gt;;</div>
<div class="line">    <span class="keyword">using </span>connect_handler = std::function&lt;void(</div>
<div class="line">        std::shared_ptr&lt;session::messaging_session&gt;)&gt;;</div>
<div class="line">    <span class="keyword">using </span>disconnect_handler = std::function&lt;void(</div>
<div class="line">        std::shared_ptr&lt;session::messaging_session&gt;,</div>
<div class="line">        <span class="keyword">const</span> std::string&amp;)&gt;;</div>
<div class="line">    <span class="keyword">using </span>error_handler = std::function&lt;void(</div>
<div class="line">        <span class="keyword">const</span> std::string&amp;, <span class="keywordtype">int</span>)&gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> set_message_handler(message_handler handler);</div>
<div class="line">    <span class="keywordtype">void</span> set_connect_handler(connect_handler handler);</div>
<div class="line">    <span class="keywordtype">void</span> set_disconnect_handler(disconnect_handler handler);</div>
<div class="line">    <span class="keywordtype">void</span> set_error_handler(error_handler handler);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Message broadcasting</span></div>
<div class="line">    <span class="keywordtype">void</span> broadcast_message(<span class="keyword">const</span> std::string&amp; message);</div>
<div class="line">    <span class="keywordtype">void</span> broadcast_to_group(<span class="keyword">const</span> std::string&amp; group_id, <span class="keyword">const</span> std::string&amp; message);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Session management</span></div>
<div class="line">    std::shared_ptr&lt;session::messaging_session&gt; get_session(</div>
<div class="line">        <span class="keyword">const</span> std::string&amp; session_id);</div>
<div class="line">    std::vector&lt;std::shared_ptr&lt;session::messaging_session&gt;&gt; get_all_sessions();</div>
<div class="line">    <span class="keywordtype">void</span> disconnect_session(<span class="keyword">const</span> std::string&amp; session_id);</div>
<div class="line">    <span class="keywordtype">void</span> disconnect_all_sessions();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Group management</span></div>
<div class="line">    <span class="keywordtype">void</span> add_session_to_group(<span class="keyword">const</span> std::string&amp; session_id,</div>
<div class="line">                              <span class="keyword">const</span> std::string&amp; group_id);</div>
<div class="line">    <span class="keywordtype">void</span> remove_session_from_group(<span class="keyword">const</span> std::string&amp; session_id,</div>
<div class="line">                                   <span class="keyword">const</span> std::string&amp; group_id);</div>
<div class="line">    std::vector&lt;std::string&gt; get_session_groups(<span class="keyword">const</span> std::string&amp; session_id);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Statistics</span></div>
<div class="line">    <span class="keyword">struct </span>server_statistics {</div>
<div class="line">        uint64_t total_connections = 0;</div>
<div class="line">        uint64_t current_connections = 0;</div>
<div class="line">        uint64_t messages_sent = 0;</div>
<div class="line">        uint64_t messages_received = 0;</div>
<div class="line">        uint64_t bytes_sent = 0;</div>
<div class="line">        uint64_t bytes_received = 0;</div>
<div class="line">        std::chrono::steady_clock::time_point start_time;</div>
<div class="line">        std::chrono::steady_clock::time_point last_activity;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    server_statistics get_statistics() <span class="keyword">const</span>;</div>
<div class="line">    <span class="keywordtype">void</span> reset_statistics();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">class </span>impl;</div>
<div class="line">    std::unique_ptr&lt;impl&gt; pimpl_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace network_system::core</span></div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md218"></a>
3. Session Management</h3>
<div class="fragment"><div class="line"><span class="comment">// include/network_system/session/messaging_session.h</span></div>
<div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;chrono&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;functional&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;unordered_map&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>network_system::session {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">enum class</span> session_state {</div>
<div class="line">    connecting,</div>
<div class="line">    connected,</div>
<div class="line">    disconnecting,</div>
<div class="line">    disconnected,</div>
<div class="line">    error</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>messaging_session {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Destructor</span></div>
<div class="line">    <span class="keyword">virtual</span> ~messaging_session() = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Message send/receive</span></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> send_message(<span class="keyword">const</span> std::string&amp; message) = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> send_raw_data(<span class="keyword">const</span> std::vector&lt;uint8_t&gt;&amp; data) = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> send_binary_message(<span class="keyword">const</span> <span class="keywordtype">void</span>* data, <span class="keywordtype">size_t</span> size) = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Session information</span></div>
<div class="line">    <span class="keyword">virtual</span> std::string session_id() <span class="keyword">const</span> = 0;</div>
<div class="line">    <span class="keyword">virtual</span> std::string client_id() <span class="keyword">const</span> = 0;</div>
<div class="line">    <span class="keyword">virtual</span> std::string remote_address() <span class="keyword">const</span> = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> remote_port() <span class="keyword">const</span> = 0;</div>
<div class="line">    <span class="keyword">virtual</span> std::string local_address() <span class="keyword">const</span> = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> local_port() <span class="keyword">const</span> = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Connection state</span></div>
<div class="line">    <span class="keyword">virtual</span> session_state state() <span class="keyword">const</span> = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> is_connected() <span class="keyword">const</span> = 0;</div>
<div class="line">    <span class="keyword">virtual</span> std::chrono::steady_clock::time_point connect_time() <span class="keyword">const</span> = 0;</div>
<div class="line">    <span class="keyword">virtual</span> std::chrono::steady_clock::time_point last_activity() <span class="keyword">const</span> = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Session management</span></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> disconnect() = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> disconnect(<span class="keyword">const</span> std::string&amp; reason) = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Session data (key-value store)</span></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> set_session_data(<span class="keyword">const</span> std::string&amp; key,</div>
<div class="line">                                  <span class="keyword">const</span> std::string&amp; value) = 0;</div>
<div class="line">    <span class="keyword">virtual</span> std::string get_session_data(<span class="keyword">const</span> std::string&amp; key) <span class="keyword">const</span> = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> has_session_data(<span class="keyword">const</span> std::string&amp; key) <span class="keyword">const</span> = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> remove_session_data(<span class="keyword">const</span> std::string&amp; key) = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> clear_session_data() = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Session groups</span></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> join_group(<span class="keyword">const</span> std::string&amp; group_id) = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> leave_group(<span class="keyword">const</span> std::string&amp; group_id) = 0;</div>
<div class="line">    <span class="keyword">virtual</span> std::vector&lt;std::string&gt; get_groups() <span class="keyword">const</span> = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> is_in_group(<span class="keyword">const</span> std::string&amp; group_id) <span class="keyword">const</span> = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Statistics</span></div>
<div class="line">    <span class="keyword">struct </span>session_statistics {</div>
<div class="line">        uint64_t messages_sent = 0;</div>
<div class="line">        uint64_t messages_received = 0;</div>
<div class="line">        uint64_t bytes_sent = 0;</div>
<div class="line">        uint64_t bytes_received = 0;</div>
<div class="line">        uint64_t errors_count = 0;</div>
<div class="line">        std::chrono::steady_clock::time_point last_message_time;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> session_statistics get_statistics() <span class="keyword">const</span> = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> reset_statistics() = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Event handlers</span></div>
<div class="line">    <span class="keyword">using </span>message_handler = std::function&lt;void(<span class="keyword">const</span> std::string&amp;)&gt;;</div>
<div class="line">    <span class="keyword">using </span>state_change_handler = std::function&lt;void(session_state, session_state)&gt;;</div>
<div class="line">    <span class="keyword">using </span>error_handler = std::function&lt;void(<span class="keyword">const</span> std::string&amp;, <span class="keywordtype">int</span>)&gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> set_message_handler(message_handler handler) = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> set_state_change_handler(state_change_handler handler) = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> set_error_handler(error_handler handler) = 0;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    messaging_session() = <span class="keywordflow">default</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Factory functions</span></div>
<div class="line">std::shared_ptr&lt;messaging_session&gt; create_tcp_session(</div>
<div class="line">    <span class="keyword">const</span> std::string&amp; session_id,</div>
<div class="line">    <span class="keyword">const</span> std::string&amp; client_id</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace network_system::session</span></div>
</div><!-- fragment --><hr  />
<h2 class="doxsection"><a class="anchor" id="autotoc_md220"></a>
🔗 Dependency Management</h2>
<h3 class="doxsection"><a class="anchor" id="autotoc_md221"></a>
1. CMake Module Files</h3>
<div class="fragment"><div class="line"># cmake/FindNetworkSystem.cmake</div>
<div class="line">find_package(PkgConfig QUIET)</div>
<div class="line"> </div>
<div class="line"># ASIO dependency</div>
<div class="line">find_package(asio CONFIG REQUIRED)</div>
<div class="line">if(NOT asio_FOUND)</div>
<div class="line">    message(FATAL_ERROR &quot;ASIO library is required for NetworkSystem&quot;)</div>
<div class="line">endif()</div>
<div class="line"> </div>
<div class="line"># fmt dependency</div>
<div class="line">find_package(fmt CONFIG REQUIRED)</div>
<div class="line">if(NOT fmt_FOUND)</div>
<div class="line">    message(FATAL_ERROR &quot;fmt library is required for NetworkSystem&quot;)</div>
<div class="line">endif()</div>
<div class="line"> </div>
<div class="line"># Check conditional dependencies</div>
<div class="line">if(BUILD_WITH_CONTAINER_SYSTEM)</div>
<div class="line">    find_package(ContainerSystem CONFIG)</div>
<div class="line">    if(NOT ContainerSystem_FOUND)</div>
<div class="line">        message(WARNING &quot;ContainerSystem not found, container integration disabled&quot;)</div>
<div class="line">        set(BUILD_WITH_CONTAINER_SYSTEM OFF)</div>
<div class="line">    endif()</div>
<div class="line">endif()</div>
<div class="line"> </div>
<div class="line">if(BUILD_WITH_THREAD_SYSTEM)</div>
<div class="line">    find_package(ThreadSystem CONFIG)</div>
<div class="line">    if(NOT ThreadSystem_FOUND)</div>
<div class="line">        message(WARNING &quot;ThreadSystem not found, thread integration disabled&quot;)</div>
<div class="line">        set(BUILD_WITH_THREAD_SYSTEM OFF)</div>
<div class="line">    endif()</div>
<div class="line">endif()</div>
<div class="line"> </div>
<div class="line"># Define library target</div>
<div class="line">if(NOT TARGET NetworkSystem::Core)</div>
<div class="line">    add_library(NetworkSystem::Core INTERFACE)</div>
<div class="line">    target_include_directories(NetworkSystem::Core INTERFACE</div>
<div class="line">        ${CMAKE_CURRENT_LIST_DIR}/../include</div>
<div class="line">    )</div>
<div class="line">    target_link_libraries(NetworkSystem::Core INTERFACE</div>
<div class="line">        asio::asio</div>
<div class="line">        fmt::fmt</div>
<div class="line">    )</div>
<div class="line"> </div>
<div class="line">    if(BUILD_WITH_CONTAINER_SYSTEM)</div>
<div class="line">        target_link_libraries(NetworkSystem::Core INTERFACE</div>
<div class="line">            ContainerSystem::Core</div>
<div class="line">        )</div>
<div class="line">        target_compile_definitions(NetworkSystem::Core INTERFACE</div>
<div class="line">            BUILD_WITH_CONTAINER_SYSTEM</div>
<div class="line">        )</div>
<div class="line">    endif()</div>
<div class="line"> </div>
<div class="line">    if(BUILD_WITH_THREAD_SYSTEM)</div>
<div class="line">        target_link_libraries(NetworkSystem::Core INTERFACE</div>
<div class="line">            ThreadSystem::Core</div>
<div class="line">        )</div>
<div class="line">        target_compile_definitions(NetworkSystem::Core INTERFACE</div>
<div class="line">            BUILD_WITH_THREAD_SYSTEM</div>
<div class="line">        )</div>
<div class="line">    endif()</div>
<div class="line">endif()</div>
<div class="line"> </div>
<div class="line"># Set variables</div>
<div class="line">set(NetworkSystem_FOUND TRUE)</div>
<div class="line">set(NetworkSystem_VERSION &quot;2.0.0&quot;)</div>
<div class="line">set(NetworkSystem_INCLUDE_DIRS ${CMAKE_CURRENT_LIST_DIR}/../include)</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md222"></a>
2. pkg-config File</h3>
<div class="fragment"><div class="line"># network-system.pc.in</div>
<div class="line">prefix=@CMAKE_INSTALL_PREFIX@</div>
<div class="line">exec_prefix=${prefix}</div>
<div class="line">libdir=${exec_prefix}/@CMAKE_INSTALL_LIBDIR@</div>
<div class="line">includedir=${prefix}/@CMAKE_INSTALL_INCLUDEDIR@</div>
<div class="line"> </div>
<div class="line">Name: NetworkSystem</div>
<div class="line">Description: High-performance modular network system</div>
<div class="line">Version: @PROJECT_VERSION@</div>
<div class="line">Requires: asio fmt</div>
<div class="line">Requires.private: @PRIVATE_DEPENDENCIES@</div>
<div class="line">Libs: -L${libdir} -lNetworkSystem</div>
<div class="line">Libs.private: @PRIVATE_LIBS@</div>
<div class="line">Cflags: -I${includedir}</div>
</div><!-- fragment --><hr  />
<h2 class="doxsection"><a class="anchor" id="autotoc_md224"></a>
🧪 Test Framework</h2>
<h3 class="doxsection"><a class="anchor" id="autotoc_md225"></a>
1. Unit Test Structure</h3>
<div class="fragment"><div class="line"><span class="comment">// tests/unit/core/test_messaging_server.cpp</span></div>
<div class="line"><span class="preprocessor">#include &lt;gtest/gtest.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;network_system/core/messaging_server.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;network_system/core/messaging_client.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;test_utils/network_test_utils.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>network_system::test {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MessagingServerTest : <span class="keyword">public</span> ::testing::Test {</div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="keywordtype">void</span> SetUp()<span class="keyword"> override </span>{</div>
<div class="line">        server_config config;</div>
<div class="line">        config.port = test_utils::get_free_port();</div>
<div class="line">        config.max_connections = 10;</div>
<div class="line"> </div>
<div class="line">        server_ = std::make_shared&lt;core::messaging_server&gt;(<span class="stringliteral">&quot;test_server&quot;</span>, config);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Set test handlers</span></div>
<div class="line">        server_-&gt;set_message_handler([<span class="keyword">this</span>](<span class="keyword">auto</span> session, <span class="keyword">const</span> std::string&amp; msg) {</div>
<div class="line">            received_messages_.push_back(msg);</div>
<div class="line">            last_session_ = session;</div>
<div class="line">        });</div>
<div class="line"> </div>
<div class="line">        server_-&gt;set_connect_handler([<span class="keyword">this</span>](<span class="keyword">auto</span> session) {</div>
<div class="line">            connected_sessions_.push_back(session-&gt;session_id());</div>
<div class="line">        });</div>
<div class="line"> </div>
<div class="line">        server_-&gt;set_disconnect_handler([<span class="keyword">this</span>](<span class="keyword">auto</span> session, <span class="keyword">const</span> std::string&amp; reason) {</div>
<div class="line">            disconnected_sessions_.push_back(session-&gt;session_id());</div>
<div class="line">            disconnect_reasons_.push_back(reason);</div>
<div class="line">        });</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> TearDown()<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keywordflow">if</span> (server_ &amp;&amp; server_-&gt;is_running()) {</div>
<div class="line">            server_-&gt;stop_server();</div>
<div class="line">        }</div>
<div class="line">        server_.reset();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::shared_ptr&lt;core::messaging_server&gt; server_;</div>
<div class="line">    std::vector&lt;std::string&gt; received_messages_;</div>
<div class="line">    std::vector&lt;std::string&gt; connected_sessions_;</div>
<div class="line">    std::vector&lt;std::string&gt; disconnected_sessions_;</div>
<div class="line">    std::vector&lt;std::string&gt; disconnect_reasons_;</div>
<div class="line">    std::shared_ptr&lt;session::messaging_session&gt; last_session_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">TEST_F(MessagingServerTest, ServerStartStop) {</div>
<div class="line">    EXPECT_FALSE(server_-&gt;is_running());</div>
<div class="line"> </div>
<div class="line">    EXPECT_TRUE(server_-&gt;start_server());</div>
<div class="line">    EXPECT_TRUE(server_-&gt;is_running());</div>
<div class="line"> </div>
<div class="line">    server_-&gt;stop_server();</div>
<div class="line">    EXPECT_FALSE(server_-&gt;is_running());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">TEST_F(MessagingServerTest, ClientConnection) {</div>
<div class="line">    ASSERT_TRUE(server_-&gt;start_server());</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> client = std::make_shared&lt;core::messaging_client&gt;(<span class="stringliteral">&quot;test_client&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">bool</span> connected = <span class="keyword">false</span>;</div>
<div class="line">    client-&gt;set_connect_handler([&amp;connected]() {</div>
<div class="line">        connected = <span class="keyword">true</span>;</div>
<div class="line">    });</div>
<div class="line"> </div>
<div class="line">    EXPECT_TRUE(client-&gt;start_client(<span class="stringliteral">&quot;127.0.0.1&quot;</span>, server_-&gt;port()));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Wait for connection</span></div>
<div class="line">    test_utils::wait_for_condition([&amp;connected]() { <span class="keywordflow">return</span> connected; },</div>
<div class="line">                                   std::chrono::seconds(5));</div>
<div class="line"> </div>
<div class="line">    EXPECT_TRUE(connected);</div>
<div class="line">    EXPECT_EQ(1, connected_sessions_.size());</div>
<div class="line">    EXPECT_EQ(1, server_-&gt;connection_count());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">TEST_F(MessagingServerTest, MessageExchange) {</div>
<div class="line">    ASSERT_TRUE(server_-&gt;start_server());</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> client = std::make_shared&lt;core::messaging_client&gt;(<span class="stringliteral">&quot;test_client&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    std::string received_message;</div>
<div class="line">    client-&gt;set_message_handler([&amp;received_message](<span class="keyword">const</span> std::string&amp; msg) {</div>
<div class="line">        received_message = msg;</div>
<div class="line">    });</div>
<div class="line"> </div>
<div class="line">    ASSERT_TRUE(client-&gt;start_client(<span class="stringliteral">&quot;127.0.0.1&quot;</span>, server_-&gt;port()));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Wait for connection</span></div>
<div class="line">    test_utils::wait_for_condition([<span class="keyword">this</span>]() {</div>
<div class="line">        <span class="keywordflow">return</span> !connected_sessions_.empty();</div>
<div class="line">    }, std::chrono::seconds(5));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Send message from client to server</span></div>
<div class="line">    <span class="keyword">const</span> std::string test_message = <span class="stringliteral">&quot;Hello, Server!&quot;</span>;</div>
<div class="line">    client-&gt;send_message(test_message);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Wait for message reception</span></div>
<div class="line">    test_utils::wait_for_condition([<span class="keyword">this</span>]() {</div>
<div class="line">        <span class="keywordflow">return</span> !received_messages_.empty();</div>
<div class="line">    }, std::chrono::seconds(5));</div>
<div class="line"> </div>
<div class="line">    EXPECT_EQ(1, received_messages_.size());</div>
<div class="line">    EXPECT_EQ(test_message, received_messages_[0]);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Send response from server to client</span></div>
<div class="line">    <span class="keyword">const</span> std::string response_message = <span class="stringliteral">&quot;Hello, Client!&quot;</span>;</div>
<div class="line">    ASSERT_NE(<span class="keyword">nullptr</span>, last_session_);</div>
<div class="line">    last_session_-&gt;send_message(response_message);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Wait for response reception</span></div>
<div class="line">    test_utils::wait_for_condition([&amp;received_message, &amp;response_message]() {</div>
<div class="line">        <span class="keywordflow">return</span> received_message == response_message;</div>
<div class="line">    }, std::chrono::seconds(5));</div>
<div class="line"> </div>
<div class="line">    EXPECT_EQ(response_message, received_message);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">TEST_F(MessagingServerTest, MaxConnectionsLimit) {</div>
<div class="line">    server_config config = server_-&gt;get_config();</div>
<div class="line">    config.max_connections = 2;</div>
<div class="line">    server_-&gt;set_config(config);</div>
<div class="line"> </div>
<div class="line">    ASSERT_TRUE(server_-&gt;start_server());</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create clients up to max connections</span></div>
<div class="line">    std::vector&lt;std::shared_ptr&lt;core::messaging_client&gt;&gt; clients;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++i) {</div>
<div class="line">        <span class="keyword">auto</span> client = std::make_shared&lt;core::messaging_client&gt;(</div>
<div class="line">            <span class="stringliteral">&quot;test_client_&quot;</span> + std::to_string(i));</div>
<div class="line">        clients.push_back(client);</div>
<div class="line"> </div>
<div class="line">        client-&gt;start_client(<span class="stringliteral">&quot;127.0.0.1&quot;</span>, server_-&gt;port());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Wait briefly</span></div>
<div class="line">    std::this_thread::sleep_for(std::chrono::milliseconds(100));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Verify max connections not exceeded</span></div>
<div class="line">    EXPECT_LE(server_-&gt;connection_count(), 2);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace network_system::test</span></div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md226"></a>
2. Integration Tests</h3>
<div class="fragment"><div class="line"><span class="comment">// tests/integration/test_container_integration.cpp</span></div>
<div class="line"><span class="preprocessor">#ifdef BUILD_WITH_CONTAINER_SYSTEM</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;gtest/gtest.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;network_system/integration/messaging_bridge.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;container_system/value_container.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>network_system::test {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>ContainerIntegrationTest : <span class="keyword">public</span> ::testing::Test {</div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="keywordtype">void</span> SetUp()<span class="keyword"> override </span>{</div>
<div class="line">        bridge_ = std::make_unique&lt;integration::messaging_bridge&gt;(<span class="stringliteral">&quot;test_bridge&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Set container_system factory</span></div>
<div class="line">        <span class="keyword">auto</span> factory = std::make_shared&lt;container_system::value_factory&gt;();</div>
<div class="line">        bridge_-&gt;set_container_factory(factory);</div>
<div class="line">        bridge_-&gt;enable_container_serialization(<span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Set container message handler</span></div>
<div class="line">        bridge_-&gt;set_container_message_handler([<span class="keyword">this</span>](<span class="keyword">auto</span> container) {</div>
<div class="line">            received_containers_.push_back(container);</div>
<div class="line">        });</div>
<div class="line"> </div>
<div class="line">        bridge_-&gt;start();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> TearDown()<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keywordflow">if</span> (bridge_) {</div>
<div class="line">            bridge_-&gt;stop();</div>
<div class="line">        }</div>
<div class="line">        bridge_.reset();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::unique_ptr&lt;integration::messaging_bridge&gt; bridge_;</div>
<div class="line">    std::vector&lt;std::shared_ptr&lt;container_system::value_container&gt;&gt; received_containers_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">TEST_F(ContainerIntegrationTest, ContainerSerialization) {</div>
<div class="line">    <span class="keyword">auto</span> server = bridge_-&gt;create_server(<span class="stringliteral">&quot;test_server&quot;</span>);</div>
<div class="line">    <span class="keyword">auto</span> client = bridge_-&gt;create_client(<span class="stringliteral">&quot;test_client&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    ASSERT_TRUE(server-&gt;start_server(0)); <span class="comment">// Random port</span></div>
<div class="line">    ASSERT_TRUE(client-&gt;start_client(<span class="stringliteral">&quot;127.0.0.1&quot;</span>, server-&gt;port()));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create container message</span></div>
<div class="line">    <span class="keyword">auto</span> container = std::make_shared&lt;container_system::value_container&gt;();</div>
<div class="line">    container-&gt;set_source(<span class="stringliteral">&quot;test_client&quot;</span>, <span class="stringliteral">&quot;main&quot;</span>);</div>
<div class="line">    container-&gt;set_target(<span class="stringliteral">&quot;test_server&quot;</span>, <span class="stringliteral">&quot;handler&quot;</span>);</div>
<div class="line">    container-&gt;set_message_type(<span class="stringliteral">&quot;test_message&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> values = std::vector&lt;std::shared_ptr&lt;container_system::value&gt;&gt;{</div>
<div class="line">        container_system::value_factory::create(<span class="stringliteral">&quot;text&quot;</span>,</div>
<div class="line">            container_system::string_value, <span class="stringliteral">&quot;Hello, Container!&quot;</span>),</div>
<div class="line">        container_system::value_factory::create(<span class="stringliteral">&quot;number&quot;</span>,</div>
<div class="line">            container_system::int32_value, <span class="stringliteral">&quot;42&quot;</span>)</div>
<div class="line">    };</div>
<div class="line">    container-&gt;set_values(values);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Send container</span></div>
<div class="line">    std::string serialized = container-&gt;serialize();</div>
<div class="line">    client-&gt;send_message(serialized);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Wait for reception</span></div>
<div class="line">    test_utils::wait_for_condition([<span class="keyword">this</span>]() {</div>
<div class="line">        <span class="keywordflow">return</span> !received_containers_.empty();</div>
<div class="line">    }, std::chrono::seconds(5));</div>
<div class="line"> </div>
<div class="line">    ASSERT_EQ(1, received_containers_.size());</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> received = received_containers_[0];</div>
<div class="line">    EXPECT_EQ(<span class="stringliteral">&quot;test_message&quot;</span>, received-&gt;message_type());</div>
<div class="line">    EXPECT_EQ(<span class="stringliteral">&quot;test_client&quot;</span>, received-&gt;source_id());</div>
<div class="line">    EXPECT_EQ(<span class="stringliteral">&quot;test_server&quot;</span>, received-&gt;target_id());</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> text_value = received-&gt;get_value(<span class="stringliteral">&quot;text&quot;</span>);</div>
<div class="line">    ASSERT_NE(<span class="keyword">nullptr</span>, text_value);</div>
<div class="line">    EXPECT_EQ(<span class="stringliteral">&quot;Hello, Container!&quot;</span>, text_value-&gt;to_string());</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> number_value = received-&gt;get_value(<span class="stringliteral">&quot;number&quot;</span>);</div>
<div class="line">    ASSERT_NE(<span class="keyword">nullptr</span>, number_value);</div>
<div class="line">    EXPECT_EQ(42, number_value-&gt;to_int32());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace network_system::test</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// BUILD_WITH_CONTAINER_SYSTEM</span></div>
</div><!-- fragment --><hr  />
<h2 class="doxsection"><a class="anchor" id="autotoc_md228"></a>
📊 Performance Monitoring</h2>
<h3 class="doxsection"><a class="anchor" id="autotoc_md229"></a>
1. Performance Metric Collection</h3>
<div class="fragment"><div class="line"><span class="comment">// include/network_system/utils/performance_monitor.h</span></div>
<div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;atomic&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;chrono&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;unordered_map&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>network_system::utils {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>performance_monitor {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">struct </span>metrics {</div>
<div class="line">        <span class="comment">// Connection metrics</span></div>
<div class="line">        std::atomic&lt;uint64_t&gt; total_connections{0};</div>
<div class="line">        std::atomic&lt;uint64_t&gt; active_connections{0};</div>
<div class="line">        std::atomic&lt;uint64_t&gt; failed_connections{0};</div>
<div class="line">        std::atomic&lt;uint64_t&gt; connections_per_second{0};</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Message metrics</span></div>
<div class="line">        std::atomic&lt;uint64_t&gt; messages_sent{0};</div>
<div class="line">        std::atomic&lt;uint64_t&gt; messages_received{0};</div>
<div class="line">        std::atomic&lt;uint64_t&gt; messages_per_second{0};</div>
<div class="line">        std::atomic&lt;uint64_t&gt; bytes_sent{0};</div>
<div class="line">        std::atomic&lt;uint64_t&gt; bytes_received{0};</div>
<div class="line">        std::atomic&lt;uint64_t&gt; bytes_per_second{0};</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Latency metrics (microseconds)</span></div>
<div class="line">        std::atomic&lt;uint64_t&gt; avg_latency_us{0};</div>
<div class="line">        std::atomic&lt;uint64_t&gt; min_latency_us{UINT64_MAX};</div>
<div class="line">        std::atomic&lt;uint64_t&gt; max_latency_us{0};</div>
<div class="line">        std::atomic&lt;uint64_t&gt; p95_latency_us{0};</div>
<div class="line">        std::atomic&lt;uint64_t&gt; p99_latency_us{0};</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Error metrics</span></div>
<div class="line">        std::atomic&lt;uint64_t&gt; send_errors{0};</div>
<div class="line">        std::atomic&lt;uint64_t&gt; receive_errors{0};</div>
<div class="line">        std::atomic&lt;uint64_t&gt; timeout_errors{0};</div>
<div class="line">        std::atomic&lt;uint64_t&gt; connection_errors{0};</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Memory metrics</span></div>
<div class="line">        std::atomic&lt;uint64_t&gt; memory_usage_bytes{0};</div>
<div class="line">        std::atomic&lt;uint64_t&gt; buffer_pool_size{0};</div>
<div class="line">        std::atomic&lt;uint64_t&gt; peak_memory_usage{0};</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Time information</span></div>
<div class="line">        std::chrono::steady_clock::time_point start_time;</div>
<div class="line">        std::chrono::steady_clock::time_point last_update;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Calculate uptime</span></div>
<div class="line">        std::chrono::milliseconds uptime()<span class="keyword"> const </span>{</div>
<div class="line">            <span class="keywordflow">return</span> std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(</div>
<div class="line">                std::chrono::steady_clock::now() - start_time);</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> performance_monitor&amp; instance();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Update metrics</span></div>
<div class="line">    <span class="keywordtype">void</span> record_connection(<span class="keywordtype">bool</span> success);</div>
<div class="line">    <span class="keywordtype">void</span> record_disconnection();</div>
<div class="line">    <span class="keywordtype">void</span> record_message_sent(<span class="keywordtype">size_t</span> bytes);</div>
<div class="line">    <span class="keywordtype">void</span> record_message_received(<span class="keywordtype">size_t</span> bytes);</div>
<div class="line">    <span class="keywordtype">void</span> record_latency(std::chrono::microseconds latency);</div>
<div class="line">    <span class="keywordtype">void</span> record_error(<span class="keyword">const</span> std::string&amp; error_type);</div>
<div class="line">    <span class="keywordtype">void</span> record_memory_usage(<span class="keywordtype">size_t</span> bytes);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Query metrics</span></div>
<div class="line">    metrics get_metrics() <span class="keyword">const</span>;</div>
<div class="line">    <span class="keywordtype">void</span> reset_metrics();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Real-time statistics calculation</span></div>
<div class="line">    <span class="keywordtype">void</span> update_realtime_stats();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Export metrics as JSON</span></div>
<div class="line">    std::string to_json() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Generate performance report</span></div>
<div class="line">    std::string generate_report() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    performance_monitor();</div>
<div class="line">    ~performance_monitor() = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">    performance_monitor(<span class="keyword">const</span> performance_monitor&amp;) = <span class="keyword">delete</span>;</div>
<div class="line">    performance_monitor&amp; operator=(<span class="keyword">const</span> performance_monitor&amp;) = <span class="keyword">delete</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">class </span>impl;</div>
<div class="line">    std::unique_ptr&lt;impl&gt; pimpl_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace network_system::utils</span></div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md230"></a>
2. Benchmark Tools</h3>
<div class="fragment"><div class="line"><span class="comment">// tests/performance/benchmark_network_performance.cpp</span></div>
<div class="line"><span class="preprocessor">#include &lt;benchmark/benchmark.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;network_system/core/messaging_server.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;network_system/core/messaging_client.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>network_system::benchmark {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>NetworkBenchmark {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    NetworkBenchmark() {</div>
<div class="line">        server_ = std::make_shared&lt;core::messaging_server&gt;(<span class="stringliteral">&quot;bench_server&quot;</span>);</div>
<div class="line">        server_-&gt;set_message_handler([](<span class="keyword">auto</span> session, <span class="keyword">const</span> std::string&amp; msg) {</div>
<div class="line">            <span class="comment">// Echo server</span></div>
<div class="line">            session-&gt;send_message(msg);</div>
<div class="line">        });</div>
<div class="line"> </div>
<div class="line">        server_-&gt;start_server(0); <span class="comment">// Random port</span></div>
<div class="line">        port_ = server_-&gt;port();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    ~NetworkBenchmark() {</div>
<div class="line">        server_-&gt;stop_server();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> get_port()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> port_; }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::shared_ptr&lt;core::messaging_server&gt; server_;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> port_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> NetworkBenchmark* g_benchmark = <span class="keyword">nullptr</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> BM_SingleClientEcho(::benchmark::State&amp; state) {</div>
<div class="line">    <span class="keywordflow">if</span> (!g_benchmark) {</div>
<div class="line">        g_benchmark = <span class="keyword">new</span> NetworkBenchmark();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> client = std::make_shared&lt;core::messaging_client&gt;(<span class="stringliteral">&quot;bench_client&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    std::atomic&lt;int&gt; received_count{0};</div>
<div class="line">    client-&gt;set_message_handler([&amp;received_count](<span class="keyword">const</span> std::string&amp;) {</div>
<div class="line">        received_count++;</div>
<div class="line">    });</div>
<div class="line"> </div>
<div class="line">    client-&gt;start_client(<span class="stringliteral">&quot;127.0.0.1&quot;</span>, g_benchmark-&gt;get_port());</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Wait for connection</span></div>
<div class="line">    std::this_thread::sleep_for(std::chrono::milliseconds(10));</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> std::string message = <span class="stringliteral">&quot;benchmark_message&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> _ : state) {</div>
<div class="line">        client-&gt;send_message(message);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Wait for response</span></div>
<div class="line">        <span class="keyword">auto</span> start = std::chrono::steady_clock::now();</div>
<div class="line">        <span class="keywordflow">while</span> (received_count.load() == 0) {</div>
<div class="line">            <span class="keyword">auto</span> now = std::chrono::steady_clock::now();</div>
<div class="line">            <span class="keywordflow">if</span> (now - start &gt; std::chrono::seconds(1)) {</div>
<div class="line">                state.SkipWithError(<span class="stringliteral">&quot;Timeout waiting for response&quot;</span>);</div>
<div class="line">                <span class="keywordflow">return</span>;</div>
<div class="line">            }</div>
<div class="line">            std::this_thread::sleep_for(std::chrono::microseconds(1));</div>
<div class="line">        }</div>
<div class="line">        received_count--;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    state.SetItemsProcessed(state.iterations());</div>
<div class="line">    state.SetBytesProcessed(state.iterations() * message.size() * 2); <span class="comment">// Send+receive</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> BM_MultipleClientsEcho(::benchmark::State&amp; state) {</div>
<div class="line">    <span class="keywordflow">if</span> (!g_benchmark) {</div>
<div class="line">        g_benchmark = <span class="keyword">new</span> NetworkBenchmark();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> num_clients = state.range(0);</div>
<div class="line">    std::vector&lt;std::shared_ptr&lt;core::messaging_client&gt;&gt; clients;</div>
<div class="line">    std::atomic&lt;int&gt; total_received{0};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create and connect clients</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; num_clients; ++i) {</div>
<div class="line">        <span class="keyword">auto</span> client = std::make_shared&lt;core::messaging_client&gt;(</div>
<div class="line">            <span class="stringliteral">&quot;bench_client_&quot;</span> + std::to_string(i));</div>
<div class="line"> </div>
<div class="line">        client-&gt;set_message_handler([&amp;total_received](<span class="keyword">const</span> std::string&amp;) {</div>
<div class="line">            total_received++;</div>
<div class="line">        });</div>
<div class="line"> </div>
<div class="line">        client-&gt;start_client(<span class="stringliteral">&quot;127.0.0.1&quot;</span>, g_benchmark-&gt;get_port());</div>
<div class="line">        clients.push_back(client);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Wait for all clients to connect</span></div>
<div class="line">    std::this_thread::sleep_for(std::chrono::milliseconds(100));</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> std::string message = <span class="stringliteral">&quot;benchmark_message&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> _ : state) {</div>
<div class="line">        <span class="comment">// Send messages from all clients simultaneously</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; client : clients) {</div>
<div class="line">            client-&gt;send_message(message);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Wait for all responses</span></div>
<div class="line">        <span class="keyword">auto</span> start = std::chrono::steady_clock::now();</div>
<div class="line">        <span class="keywordflow">while</span> (total_received.load() &lt; num_clients) {</div>
<div class="line">            <span class="keyword">auto</span> now = std::chrono::steady_clock::now();</div>
<div class="line">            <span class="keywordflow">if</span> (now - start &gt; std::chrono::seconds(5)) {</div>
<div class="line">                state.SkipWithError(<span class="stringliteral">&quot;Timeout waiting for responses&quot;</span>);</div>
<div class="line">                <span class="keywordflow">return</span>;</div>
<div class="line">            }</div>
<div class="line">            std::this_thread::sleep_for(std::chrono::microseconds(10));</div>
<div class="line">        }</div>
<div class="line">        total_received -= num_clients;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    state.SetItemsProcessed(state.iterations() * num_clients);</div>
<div class="line">    state.SetBytesProcessed(state.iterations() * num_clients * message.size() * 2);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> BM_LargeMessageTransfer(::benchmark::State&amp; state) {</div>
<div class="line">    <span class="keywordflow">if</span> (!g_benchmark) {</div>
<div class="line">        g_benchmark = <span class="keyword">new</span> NetworkBenchmark();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> client = std::make_shared&lt;core::messaging_client&gt;(<span class="stringliteral">&quot;bench_client&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    std::atomic&lt;bool&gt; received{<span class="keyword">false</span>};</div>
<div class="line">    client-&gt;set_message_handler([&amp;received](<span class="keyword">const</span> std::string&amp;) {</div>
<div class="line">        received = <span class="keyword">true</span>;</div>
<div class="line">    });</div>
<div class="line"> </div>
<div class="line">    client-&gt;start_client(<span class="stringliteral">&quot;127.0.0.1&quot;</span>, g_benchmark-&gt;get_port());</div>
<div class="line">    std::this_thread::sleep_for(std::chrono::milliseconds(10));</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">size_t</span> message_size = state.range(0);</div>
<div class="line">    <span class="keyword">const</span> std::string message(message_size, <span class="charliteral">&#39;X&#39;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> _ : state) {</div>
<div class="line">        received = <span class="keyword">false</span>;</div>
<div class="line">        client-&gt;send_message(message);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Wait for response</span></div>
<div class="line">        <span class="keyword">auto</span> start = std::chrono::steady_clock::now();</div>
<div class="line">        <span class="keywordflow">while</span> (!received.load()) {</div>
<div class="line">            <span class="keyword">auto</span> now = std::chrono::steady_clock::now();</div>
<div class="line">            <span class="keywordflow">if</span> (now - start &gt; std::chrono::seconds(5)) {</div>
<div class="line">                state.SkipWithError(<span class="stringliteral">&quot;Timeout waiting for response&quot;</span>);</div>
<div class="line">                <span class="keywordflow">return</span>;</div>
<div class="line">            }</div>
<div class="line">            std::this_thread::sleep_for(std::chrono::microseconds(10));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    state.SetItemsProcessed(state.iterations());</div>
<div class="line">    state.SetBytesProcessed(state.iterations() * message_size * 2);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Register benchmarks</span></div>
<div class="line">BENCHMARK(BM_SingleClientEcho)</div>
<div class="line">    -&gt;Unit(::benchmark::kMicrosecond)</div>
<div class="line">    -&gt;Iterations(10000);</div>
<div class="line"> </div>
<div class="line">BENCHMARK(BM_MultipleClientsEcho)</div>
<div class="line">    -&gt;Unit(::benchmark::kMicrosecond)</div>
<div class="line">    -&gt;Arg(1)-&gt;Arg(10)-&gt;Arg(50)-&gt;Arg(100)</div>
<div class="line">    -&gt;Iterations(1000);</div>
<div class="line"> </div>
<div class="line">BENCHMARK(BM_LargeMessageTransfer)</div>
<div class="line">    -&gt;Unit(::benchmark::kMicrosecond)</div>
<div class="line">    -&gt;Arg(1024)-&gt;Arg(8192)-&gt;Arg(65536)-&gt;Arg(1048576)</div>
<div class="line">    -&gt;Iterations(100);</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace network_system::benchmark</span></div>
<div class="line"> </div>
<div class="line">BENCHMARK_MAIN();</div>
</div><!-- fragment --><hr  />
<p>This technical implementation details document provides a comprehensive guide for the network_system separation work. The next step would be to create migration scripts. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
