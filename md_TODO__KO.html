<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Network System: Network System - 미구현 기능 목록</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Network System
   </div>
   <div id="projectbrief">High-performance modular networking library for scalable client-server applications</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Network System - 미구현 기능 목록</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md532"></a> </p><blockquote class="doxtable">
<p>&zwj;<b>Language:</b> <a class="el" href="md_TODO.html">English</a> | <b>한국어</b> </p>
</blockquote>
<h1><a class="anchor" id="autotoc_md533"></a>
개요</h1>
<p>이 문서는 network system에서 계획되었지만 아직 구현되지 않은 기능들을 추적합니다. 기능은 우선순위와 예상 구현 소요 시간에 따라 구성됩니다.</p>
<p><b>최종 업데이트:</b> 2025-11-27 <b>버전:</b> 1.8.0</p>
<hr  />
<h1><a class="anchor" id="autotoc_md535"></a>
높은 우선순위 기능 (P2)</h1>
<h2><a class="anchor" id="autotoc_md536"></a>
&lt;strike&gt;1. 클라이언트 재연결 로직&lt;/strike&gt; ✅ 완료</h2>
<p><b>상태:</b> v1.5.0에서 구현됨 <b>우선순위:</b> P2 <b>실제 소요:</b> 2일 <b>완료일:</b> 2025-01-26</p>
<p><b>설명:</b> 네트워크 중단을 우아하게 처리하기 위해 <code>messaging_client</code> 및 <code>secure_messaging_client</code>에 대한 지수 백오프를 사용한 자동 재연결 로직을 추가합니다.</p>
<p><b>제안된 구현:</b> </p><div class="fragment"><div class="line"><span class="keyword">class </span>resilient_client {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    resilient_client(<span class="keyword">const</span> std::string&amp; host, <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> port,</div>
<div class="line">                    <span class="keywordtype">size_t</span> max_retries = 3,</div>
<div class="line">                    std::chrono::milliseconds initial_backoff = std::chrono::seconds(1));</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> send_with_retry(std::vector&lt;uint8_t&gt;&amp;&amp; data) -&gt; VoidResult;</div>
<div class="line">    <span class="keyword">auto</span> reconnect() -&gt; VoidResult;</div>
<div class="line">    <span class="keyword">auto</span> set_reconnect_callback(std::function&lt;<span class="keywordtype">void</span>(<span class="keywordtype">size_t</span> attempt)&gt; callback) -&gt; void;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::unique_ptr&lt;messaging_client&gt; client_;</div>
<div class="line">    <span class="keywordtype">size_t</span> max_retries_;</div>
<div class="line">    std::chrono::milliseconds initial_backoff_;</div>
<div class="line">    std::function&lt;void(<span class="keywordtype">size_t</span>)&gt; reconnect_callback_;</div>
<div class="line">};</div>
</div><!-- fragment --><p><b>이점:</b></p><ul>
<li>네트워크 장애로부터 자동 복구</li>
<li>지수 백오프로 연결 폭주 방지</li>
<li>구성 가능한 재시도 동작</li>
<li>재연결 이벤트에 대한 콜백 지원</li>
</ul>
<p><b>관련 파일:</b></p><ul>
<li><code>include/network_system/core/messaging_client.h</code></li>
<li><code>include/network_system/core/secure_messaging_client.h</code></li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md538"></a>
&lt;strike&gt;2. HTTP/2 클라이언트 지원&lt;/strike&gt; ✅ 완료</h2>
<p><b>상태:</b> v1.9.0에서 구현됨 <b>우선순위:</b> P2 <b>실제 소요:</b> 1일 <b>완료일:</b> 2025-11-27</p>
<p><b>설명:</b> 멀티플렉싱, 서버 푸시, 헤더 압축을 포함한 현대적인 웹 서비스 통신을 위한 HTTP/2 프로토콜 지원을 구현합니다.</p>
<p><b>구현된 기능:</b></p><ul>
<li>완전한 HTTP/2 프로토콜 구현 (RFC 7540)</li>
<li>단일 연결을 통한 스트림 멀티플렉싱</li>
<li>HPACK 헤더 압축 (RFC 7541)</li>
<li>TLS 1.3 및 ALPN 협상 ("h2")</li>
<li>WINDOW_UPDATE를 통한 흐름 제어</li>
<li>연결 유지를 위한 PING/PONG</li>
<li>GOAWAY를 통한 정상 종료</li>
<li>ASIO를 통한 비동기 I/O</li>
</ul>
<p><b>API:</b> </p><div class="fragment"><div class="line"><span class="keyword">class </span>http2_client {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">explicit</span> http2_client(std::string_view client_id);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> connect(<span class="keyword">const</span> std::string&amp; host, <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> port = 443) -&gt; VoidResult;</div>
<div class="line">    <span class="keyword">auto</span> disconnect() -&gt; VoidResult;</div>
<div class="line">    <span class="keyword">auto</span> is_connected() const -&gt; <span class="keywordtype">bool</span>;</div>
<div class="line"> </div>
<div class="line">    auto get(const std::<span class="keywordtype">string</span>&amp; path,</div>
<div class="line">             const std::vector&lt;http_header&gt;&amp; headers = {}) -&gt; Result&lt;http2_response&gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> post(<span class="keyword">const</span> std::string&amp; path,</div>
<div class="line">              <span class="keyword">const</span> std::string&amp; body,</div>
<div class="line">              <span class="keyword">const</span> std::vector&lt;http_header&gt;&amp; headers = {}) -&gt; Result&lt;http2_response&gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> put(<span class="keyword">const</span> std::string&amp; path,</div>
<div class="line">             <span class="keyword">const</span> std::string&amp; body,</div>
<div class="line">             <span class="keyword">const</span> std::vector&lt;http_header&gt;&amp; headers = {}) -&gt; Result&lt;http2_response&gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> del(<span class="keyword">const</span> std::string&amp; path,</div>
<div class="line">             <span class="keyword">const</span> std::vector&lt;http_header&gt;&amp; headers = {}) -&gt; Result&lt;http2_response&gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> set_timeout(std::chrono::milliseconds timeout) -&gt; void;</div>
<div class="line">    <span class="keyword">auto</span> get_timeout() const -&gt; std::chrono::milliseconds;</div>
<div class="line">};</div>
</div><!-- fragment --><p><b>관련 파일:</b></p><ul>
<li><code>include/kcenon/network/protocols/http2/http2_client.h</code></li>
<li><code>src/protocols/http2/http2_client.cpp</code></li>
<li><code>tests/test_http2_client.cpp</code></li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md540"></a>
3. gRPC 통합</h2>
<p><b>상태:</b> 미구현 <b>우선순위:</b> P2 <b>예상 소요:</b> 7-10일 <b>목표 버전:</b> v2.0.0</p>
<p><b>설명:</b> Protocol Buffers를 사용한 고성능 RPC 통신을 위한 gRPC 프로토콜 지원을 추가합니다.</p>
<p><b>주요 기능:</b></p><ul>
<li>HTTP/2 전송을 통한 gRPC</li>
<li>단일 RPC 호출</li>
<li>서버 스트리밍</li>
<li>클라이언트 스트리밍</li>
<li>양방향 스트리밍</li>
<li>데드라인/타임아웃 지원</li>
<li>메타데이터 처리</li>
</ul>
<p><b>제안된 API:</b> </p><div class="fragment"><div class="line"><span class="keyword">class </span>grpc_client {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    grpc_client(<span class="keyword">const</span> std::string&amp; host, <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> port,</div>
<div class="line">               <span class="keyword">const</span> grpc_channel_config&amp; config = {});</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Request, <span class="keyword">typename</span> Response&gt;</div>
<div class="line">    <span class="keyword">auto</span> call(<span class="keyword">const</span> std::string&amp; method,</div>
<div class="line">             <span class="keyword">const</span> Request&amp; request) -&gt; Result&lt;Response&gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Request, <span class="keyword">typename</span> Response&gt;</div>
<div class="line">    <span class="keyword">auto</span> call_async(<span class="keyword">const</span> std::string&amp; method,</div>
<div class="line">                   <span class="keyword">const</span> Request&amp; request,</div>
<div class="line">                   std::function&lt;<span class="keywordtype">void</span>(Result&lt;Response&gt;)&gt; callback) -&gt; void;</div>
<div class="line">};</div>
</div><!-- fragment --><p><b>의존성:</b></p><ul>
<li>HTTP/2 지원 (먼저 구현 필요)</li>
<li>Protocol Buffers 라이브러리 (protobuf)</li>
<li>gRPC 라이브러리 (선택 사항, HTTP/2 + protobuf를 직접 사용 가능)</li>
</ul>
<p><b>관련 파일:</b></p><ul>
<li>신규: <code>include/network_system/protocols/grpc_client.h</code></li>
<li>신규: <code>src/protocols/grpc_client.cpp</code></li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md542"></a>
중간 우선순위 기능 (P3)</h1>
<h2><a class="anchor" id="autotoc_md543"></a>
&lt;strike&gt;4. Zero-Copy 파이프라인&lt;/strike&gt; ✅ 완료</h2>
<p><b>상태:</b> v1.6.0에서 구현됨 <b>우선순위:</b> P3 <b>실제 소요:</b> 3일 <b>완료일:</b> 2025-01-26</p>
<p><b>설명:</b> 송수신 작업 중 불필요한 메모리 복사를 피하도록 데이터 파이프라인을 최적화합니다.</p>
<p><b>구현된 기능:</b></p><ul>
<li>메모리 재사용을 위한 버퍼 풀 (할당 감소)</li>
<li>파이프라인 전반에 이동 의미론 적용 (복사 제거)</li>
<li>가능한 경우 제자리 변환</li>
</ul>
<p><b>제안된 개선사항:</b> </p><div class="fragment"><div class="line"><span class="keyword">class </span>zero_copy_pipeline {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// 복사 대신 버퍼 참조 사용</span></div>
<div class="line">    <span class="keyword">auto</span> transform(std::span&lt;const uint8_t&gt; input) -&gt; std::vector&lt;asio::const_buffer&gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 벡터화된 I/O 지원</span></div>
<div class="line">    <span class="keyword">auto</span> async_send_vectored(</div>
<div class="line">        std::vector&lt;asio::const_buffer&gt; buffers,</div>
<div class="line">        std::function&lt;<span class="keywordtype">void</span>(std::error_code, <span class="keywordtype">size_t</span>)&gt; handler) -&gt; void;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 버퍼 재사용을 위한 메모리 풀</span></div>
<div class="line">    <span class="keyword">auto</span> get_buffer(<span class="keywordtype">size_t</span> size) -&gt; std::shared_ptr&lt;std::vector&lt;uint8_t&gt;&gt;;</div>
<div class="line">    <span class="keyword">auto</span> release_buffer(std::shared_ptr&lt;std::vector&lt;uint8_t&gt;&gt; buffer) -&gt; void;</div>
<div class="line">};</div>
</div><!-- fragment --><p><b>이점:</b></p><ul>
<li>메모리 할당 감소</li>
<li>낮은 CPU 사용량</li>
<li>대용량 메시지에 대한 높은 처리량</li>
<li>더 나은 캐시 지역성</li>
</ul>
<p><b>관련 파일:</b></p><ul>
<li><code>include/network_system/internal/pipeline.h</code></li>
<li><code>src/internal/pipeline.cpp</code></li>
<li><code>include/network_system/internal/tcp_socket.h</code></li>
<li><code>include/network_system/internal/secure_tcp_socket.h</code></li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md545"></a>
&lt;strike&gt;5. 연결 상태 모니터링&lt;/strike&gt; ✅ 완료</h2>
<p><b>상태:</b> v1.5.0에서 구현됨 <b>우선순위:</b> P3 <b>실제 소요:</b> 3일 <b>완료일:</b> 2025-01-26</p>
<p><b>설명:</b> 죽은 연결을 조기에 감지하기 위한 하트비트/킵얼라이브 메커니즘을 사용한 연결 상태 모니터링을 추가합니다.</p>
<p><b>주요 기능:</b></p><ul>
<li>구성 가능한 하트비트 간격</li>
<li>자동 죽은 연결 감지</li>
<li>연결 품질 메트릭 (지연시간, 패킷 손실)</li>
<li>상태 콜백</li>
</ul>
<p><b>제안된 API:</b> </p><div class="fragment"><div class="line"><span class="keyword">struct </span>connection_health {</div>
<div class="line">    <span class="keywordtype">bool</span> is_alive;</div>
<div class="line">    std::chrono::milliseconds last_response_time;</div>
<div class="line">    <span class="keywordtype">size_t</span> missed_heartbeats;</div>
<div class="line">    <span class="keywordtype">double</span> packet_loss_rate;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>health_monitor {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    health_monitor(std::chrono::seconds heartbeat_interval = std::chrono::seconds(30));</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> start_monitoring(std::shared_ptr&lt;messaging_client&gt; client) -&gt; void;</div>
<div class="line">    <span class="keyword">auto</span> stop_monitoring() -&gt; void;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> get_health() const -&gt; connection_health;</div>
<div class="line">    auto set_health_callback(std::function&lt;<span class="keywordtype">void</span>(connection_health)&gt; callback) -&gt; <span class="keywordtype">void</span>;</div>
<div class="line">};</div>
</div><!-- fragment --><p><b>이점:</b></p><ul>
<li>죽은 연결의 조기 감지</li>
<li>죽은 연결에 대한 자원 낭비 감소</li>
<li>연결 품질에 대한 더 나은 가시성</li>
</ul>
<p><b>관련 파일:</b></p><ul>
<li>신규: <code>include/network_system/utils/health_monitor.h</code></li>
<li>신규: <code>src/utils/health_monitor.cpp</code></li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md547"></a>
&lt;strike&gt;6. 메시지 압축 지원&lt;/strike&gt; ✅ 완료</h2>
<p><b>상태:</b> v1.6.0에서 구현됨 <b>우선순위:</b> P3 <b>실제 소요:</b> 2일 <b>완료일:</b> 2025-01-26</p>
<p><b>설명:</b> 파이프라인에서 LZ4 알고리즘을 사용한 실제 압축을 구현합니다.</p>
<p><b>구현된 기능:</b></p><ul>
<li>LZ4 고속 압축 알고리즘</li>
<li>구성 가능한 압축 임계값 (기본값: 256바이트)</li>
<li>작은/비압축 데이터에 대한 자동 폴백</li>
<li>크기 검증을 통한 안전한 압축 해제</li>
</ul>
<p><b>제안된 구현:</b> </p><div class="fragment"><div class="line"><span class="keyword">enum class</span> compression_algorithm {</div>
<div class="line">    none,</div>
<div class="line">    zlib,</div>
<div class="line">    lz4,</div>
<div class="line">    zstd</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>compression_pipeline {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    compression_pipeline(compression_algorithm algo = compression_algorithm::lz4,</div>
<div class="line">                        <span class="keywordtype">int</span> compression_level = 3);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> compress(std::span&lt;const uint8_t&gt; input) -&gt; Result&lt;std::vector&lt;uint8_t&gt;&gt;;</div>
<div class="line">    <span class="keyword">auto</span> decompress(std::span&lt;const uint8_t&gt; input) -&gt; Result&lt;std::vector&lt;uint8_t&gt;&gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> set_compression_threshold(<span class="keywordtype">size_t</span> bytes) -&gt; void;  <span class="comment">// 작은 메시지는 압축하지 않음</span></div>
<div class="line">};</div>
</div><!-- fragment --><p><b>의존성:</b></p><ul>
<li>zlib (널리 사용 가능)</li>
<li>lz4 (선택 사항, 속도용)</li>
<li>zstd (선택 사항, 더 나은 압축용)</li>
</ul>
<p><b>이점:</b></p><ul>
<li>대역폭 사용량 감소</li>
<li>낮은 네트워크 비용</li>
<li>압축 가능한 데이터에 대한 빠른 전송</li>
</ul>
<p><b>관련 파일:</b></p><ul>
<li><code>include/network_system/internal/pipeline.h</code></li>
<li><code>src/internal/pipeline.cpp</code></li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md549"></a>
&lt;strike&gt;7. UDP 신뢰성 계층&lt;/strike&gt; ✅ 완료</h2>
<p><b>상태:</b> v1.7.0에서 구현됨 <b>우선순위:</b> P3 <b>실제 소요:</b> 3일 <b>완료일:</b> 2025-01-27</p>
<p><b>설명:</b> 속도와 신뢰성 모두를 필요로 하는 애플리케이션을 위해 UDP 위에 선택적 신뢰성 계층을 추가합니다.</p>
<p><b>주요 기능:</b></p><ul>
<li>선택적 확인응답 (SACK)</li>
<li>패킷 재전송</li>
<li>순서 보장 배달 옵션</li>
<li>혼잡 제어</li>
<li>구성 가능한 신뢰성 수준</li>
</ul>
<p><b>제안된 API:</b> </p><div class="fragment"><div class="line"><span class="keyword">enum class</span> reliability_mode {</div>
<div class="line">    unreliable,          <span class="comment">// 순수 UDP</span></div>
<div class="line">    reliable_ordered,    <span class="comment">// TCP와 유사하지만 UDP를 통해</span></div>
<div class="line">    reliable_unordered,  <span class="comment">// 순서 없는 신뢰성</span></div>
<div class="line">    sequenced           <span class="comment">// 오래된 패킷 버림, 재전송 없음</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>reliable_udp_client {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    reliable_udp_client(<span class="keyword">const</span> std::string&amp; client_id,</div>
<div class="line">                       reliability_mode mode = reliability_mode::reliable_ordered);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> start_client(<span class="keyword">const</span> std::string&amp; host, <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> port) -&gt; VoidResult;</div>
<div class="line">    <span class="keyword">auto</span> send_packet(std::vector&lt;uint8_t&gt;&amp;&amp; data) -&gt; VoidResult;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> set_congestion_window(<span class="keywordtype">size_t</span> packets) -&gt; void;</div>
<div class="line">    <span class="keyword">auto</span> set_max_retries(<span class="keywordtype">size_t</span> retries) -&gt; void;</div>
<div class="line">};</div>
</div><!-- fragment --><p><b>이점:</b></p><ul>
<li>양쪽의 장점 (UDP 속도 + TCP 신뢰성)</li>
<li>구성 가능한 트레이드오프</li>
<li>TCP보다 실시간 애플리케이션에 더 적합</li>
</ul>
<p><b>관련 파일:</b></p><ul>
<li>신규: <code>include/network_system/core/reliable_udp_client.h</code></li>
<li>신규: <code>src/core/reliable_udp_client.cpp</code></li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md551"></a>
낮은 우선순위 / 미래 기능 (P4)</h1>
<h2><a class="anchor" id="autotoc_md552"></a>
8. QUIC 프로토콜 지원</h2>
<p><b>상태:</b> 계획되지 않음 <b>우선순위:</b> P4 <b>예상 소요:</b> 15-20일 <b>목표 버전:</b> v2.1.0+</p>
<p><b>설명:</b> 현대적인 저지연 네트워킹을 위한 QUIC (Quick UDP Internet Connections) 프로토콜 지원을 추가합니다.</p>
<p><b>주요 기능:</b></p><ul>
<li>UDP 기반</li>
<li>0-RTT 연결 수립</li>
<li>멀티플렉싱 스트림</li>
<li>내장 암호화 (TLS 1.3)</li>
<li>연결 마이그레이션</li>
</ul>
<p><b>의존성:</b></p><ul>
<li>상당한 엔지니어링 노력 필요</li>
<li>복잡한 프로토콜 구현</li>
<li>타사 라이브러리 필요 가능 (예: quiche, ngtcp2)</li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md554"></a>
&lt;strike&gt;9. UDP용 DTLS 지원&lt;/strike&gt; ✅ 완료</h2>
<p><b>상태:</b> v1.8.0에서 구현됨 <b>우선순위:</b> P4 <b>실제 소요:</b> 1일 <b>완료일:</b> 2025-11-26</p>
<p><b>설명:</b> 안전한 UDP 통신을 위한 DTLS (Datagram TLS) 지원을 추가합니다.</p>
<p><b>구현된 기능:</b></p><ul>
<li><code>dtls_socket</code> - OpenSSL을 사용한 저수준 DTLS 소켓 래퍼</li>
<li><code>secure_messaging_udp_client</code> - 안전한 UDP 통신을 위한 DTLS 클라이언트</li>
<li><code>secure_messaging_udp_server</code> - 세션 관리 기능이 있는 DTLS 서버</li>
<li>ASIO 통합을 통한 전체 비동기 I/O 지원</li>
<li>스레드 안전 구현</li>
</ul>
<p><b>이점:</b></p><ul>
<li>암호화된 UDP 통신</li>
<li>실시간 애플리케이션을 위한 보안</li>
<li>기존 TLS 인프라와 호환</li>
</ul>
<p><b>관련 파일:</b></p><ul>
<li><code>include/kcenon/network/internal/dtls_socket.h</code></li>
<li><code>src/internal/dtls_socket.cpp</code></li>
<li><code>include/kcenon/network/core/secure_messaging_udp_client.h</code></li>
<li><code>src/core/secure_messaging_udp_client.cpp</code></li>
<li><code>include/kcenon/network/core/secure_messaging_udp_server.h</code></li>
<li><code>src/core/secure_messaging_udp_server.cpp</code></li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md556"></a>
10. 메트릭 및 모니터링 대시보드</h2>
<p><b>상태:</b> 계획되지 않음 <b>우선순위:</b> P4 <b>예상 소요:</b> 10-14일 <b>목표 버전:</b> v2.0.0</p>
<p><b>설명:</b> 실시간으로 network system 메트릭을 모니터링하기 위한 내장 웹 대시보드.</p>
<p><b>주요 기능:</b></p><ul>
<li>실시간 연결 통계</li>
<li>처리량 그래프</li>
<li>오류율 모니터링</li>
<li>라이브 업데이트를 위한 WebSocket</li>
<li>메트릭 내보내기를 위한 REST API</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md558"></a>
요약</h1>
<h2><a class="anchor" id="autotoc_md559"></a>
우선순위별</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">우선순위   </th><th class="markdownTableHeadNone">개수   </th><th class="markdownTableHeadNone">완료   </th><th class="markdownTableHeadNone">남은   </th><th class="markdownTableHeadNone">총 소요 시간    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">P2   </td><td class="markdownTableBodyNone">3   </td><td class="markdownTableBodyNone">2   </td><td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone">7-10일    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">P3   </td><td class="markdownTableBodyNone">4   </td><td class="markdownTableBodyNone">4   </td><td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone">0일    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">P4   </td><td class="markdownTableBodyNone">3   </td><td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone">2   </td><td class="markdownTableBodyNone">25-34일    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>총계</b>   </td><td class="markdownTableBodyNone"><b>10</b>   </td><td class="markdownTableBodyNone"><b>7</b>   </td><td class="markdownTableBodyNone"><b>3</b>   </td><td class="markdownTableBodyNone"><b>32-44일</b>   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md560"></a>
목표 버전별</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">버전   </th><th class="markdownTableHeadNone">기능   </th><th class="markdownTableHeadNone">상태   </th><th class="markdownTableHeadNone">소요 시간    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">v1.5.0   </td><td class="markdownTableBodyNone">재연결 로직, 상태 모니터링   </td><td class="markdownTableBodyNone">✅ 완료   </td><td class="markdownTableBodyNone">5일    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">v1.6.0   </td><td class="markdownTableBodyNone">Zero-Copy 파이프라인, 압축   </td><td class="markdownTableBodyNone">✅ 완료   </td><td class="markdownTableBodyNone">5일    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">v1.7.0   </td><td class="markdownTableBodyNone">UDP 신뢰성 계층   </td><td class="markdownTableBodyNone">✅ 완료   </td><td class="markdownTableBodyNone">3일    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">v1.8.0   </td><td class="markdownTableBodyNone">DTLS 지원   </td><td class="markdownTableBodyNone">✅ 완료   </td><td class="markdownTableBodyNone">1일    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">v1.9.0   </td><td class="markdownTableBodyNone">HTTP/2 클라이언트 지원   </td><td class="markdownTableBodyNone">✅ 완료   </td><td class="markdownTableBodyNone">1일    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">v2.0.0   </td><td class="markdownTableBodyNone">gRPC, 메트릭 대시보드   </td><td class="markdownTableBodyNone">대기 중   </td><td class="markdownTableBodyNone">17-24일    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">v2.1.0+   </td><td class="markdownTableBodyNone">QUIC 프로토콜   </td><td class="markdownTableBodyNone">대기 중   </td><td class="markdownTableBodyNone">15-20일   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md561"></a>
구현 로드맵</h2>
<p><b>Phase 1 (v1.5.0):</b> 안정성 및 신뢰성 ✅ 완료</p><ul>
<li>✅ 재연결 로직</li>
<li>✅ 상태 모니터링</li>
</ul>
<p><b>Phase 2 (v1.6.0):</b> 성능 최적화 ✅ 완료</p><ul>
<li>✅ Zero-copy 파이프라인 (버퍼 풀 + 이동 의미론)</li>
<li>✅ 메시지 압축 (LZ4)</li>
</ul>
<p><b>Phase 3 (v1.7.0):</b> 프로토콜 향상 ✅ 완료</p><ul>
<li>✅ UDP 신뢰성 계층</li>
</ul>
<p><b>Phase 3.5 (v1.8.0):</b> 보안 강화 ✅ 완료</p><ul>
<li>✅ DTLS 지원 (안전한 UDP 통신)</li>
</ul>
<p><b>Phase 4 (v1.9.0):</b> HTTP/2 지원 ✅ 완료</p><ul>
<li>✅ TLS 1.3 및 ALPN을 사용한 HTTP/2 클라이언트</li>
<li>✅ HPACK 헤더 압축</li>
<li>✅ 스트림 멀티플렉싱 및 흐름 제어</li>
</ul>
<p><b>Phase 5 (v2.0.0):</b> 현대적인 프로토콜</p><ul>
<li>gRPC 통합</li>
<li>모니터링 대시보드</li>
</ul>
<p><b>Phase 6 (v2.1.0+):</b> 고급 기능</p><ul>
<li>QUIC 프로토콜</li>
<li>필요에 따른 추가 프로토콜</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md563"></a>
기여하기</h1>
<p>이러한 기능 중 하나를 구현하고 싶으시다면:</p>
<ol type="1">
<li>완료된 기능에 대해서는 <a class="el" href="md_IMPROVEMENTS.html">IMPROVEMENTS.md</a>를 확인하세요</li>
<li>구현 접근 방식을 논의하기 위한 이슈를 생성하세요</li>
<li>기존 코드 스타일과 패턴을 따르세요</li>
<li>포괄적인 테스트를 추가하세요</li>
<li>문서를 업데이트하세요</li>
</ol>
<h1><a class="anchor" id="autotoc_md564"></a>
참고 사항</h1>
<ul>
<li>모든 소요 시간 추정치는 숙련된 개발자 1명을 기준으로 합니다</li>
<li>추정치에는 구현, 테스트 및 문서화가 포함됩니다</li>
<li>의존성이 구현 순서에 영향을 줄 수 있습니다</li>
<li>사용자 피드백에 따라 기능 우선순위가 변경될 수 있습니다 </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
