<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Network System: README_KO</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Network System
   </div>
   <div id="projectbrief">High-performance modular networking library for scalable client-server applications</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">README_KO</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="https://github.com/kcenon/network_system/actions/workflows/ci.yml"><img src="https://github.com/kcenon/network_system/actions/workflows/ci.yml/badge.svg" alt="CI" style="pointer-events: none;" class="inline"/></a> <a href="https://github.com/kcenon/network_system/actions/workflows/code-quality.yml"><img src="https://github.com/kcenon/network_system/actions/workflows/code-quality.yml/badge.svg" alt="Code Quality" style="pointer-events: none;" class="inline"/></a> <a href="https://github.com/kcenon/network_system/actions/workflows/coverage.yml"><img src="https://github.com/kcenon/network_system/actions/workflows/coverage.yml/badge.svg" alt="Coverage" style="pointer-events: none;" class="inline"/></a> <a href="https://github.com/kcenon/network_system/actions/workflows/build-Doxygen.yaml"><img src="https://github.com/kcenon/network_system/actions/workflows/build-Doxygen.yaml/badge.svg" alt="Doxygen" style="pointer-events: none;" class="inline"/></a></p>
<h1><a class="anchor" id="autotoc_md446"></a>
Network System Project</h1>
<blockquote class="doxtable">
<p>&zwj;<b>Language:</b> <a class="el" href="md_README.html">English</a> | <b>한국어</b> </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md447"></a>
개요</h2>
<p>Network System Project는 분산 시스템 및 메시징 애플리케이션을 위한 엔터프라이즈급 네트워킹 기능을 제공하도록 설계된 프로덕션 준비 완료 고성능 C++20 비동기 네트워크 라이브러리입니다. 향상된 모듈성을 위해 messaging_system에서 분리되었으며, 완전한 하위 호환성과 원활한 생태계 통합을 유지하면서 초당 305K+ 메시지의 뛰어난 성능을 제공합니다.</p>
<blockquote class="doxtable">
<p>&zwj;<b>🏗️ 모듈형 아키텍처</b>: zero-copy pipeline, connection pooling 및 C++20 coroutine 지원을 갖춘 고성능 비동기 네트워크 라이브러리. </p>
</blockquote>
<blockquote class="doxtable">
<p>&zwj;<b>✅ 최신 업데이트</b>: messaging_system으로부터 완전한 독립성, 향상된 성능 최적화, 포괄적인 통합 생태계 및 프로덕션 준비 완료 배포. 모든 플랫폼에서 CI/CD 파이프라인 정상 작동. </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md448"></a>
🔗 프로젝트 생태계 및 상호 의존성</h2>
<p>이 network system은 생태계 전반에 걸쳐 향상된 모듈성과 재사용성을 제공하기 위해 messaging_system에서 분리된 기본 구성 요소입니다:</p>
<h3><a class="anchor" id="autotoc_md449"></a>
역사적 배경</h3>
<ul>
<li><b>원래 통합</b>: messaging_system의 일부로 긴밀하게 결합된 네트워크 모듈</li>
<li><b>분리 근거</b>: 향상된 모듈성, 재사용성 및 유지보수성을 위해 추출</li>
<li><b>마이그레이션 성과</b>: 100% 하위 호환성을 유지하면서 완전한 독립성 달성</li>
</ul>
<h3><a class="anchor" id="autotoc_md450"></a>
관련 프로젝트</h3>
<ul>
<li><b><a href="https://github.com/kcenon/messaging_system">messaging_system</a></b>: 메시지 전송을 위해 network를 사용하는 주요 소비자<ul>
<li>관계: 메시지 전달 및 라우팅을 위한 네트워크 전송 계층</li>
<li>시너지: 엔터프라이즈급 네트워킹을 갖춘 고성능 메시징</li>
<li>통합: 원활한 메시지 직렬화 및 네트워크 전송</li>
</ul>
</li>
<li><b><a href="https://github.com/kcenon/container_system">container_system</a></b>: 네트워크 전송을 위한 데이터 직렬화<ul>
<li>관계: 직렬화된 container를 위한 네트워크 전송</li>
<li>이점: 효율적인 binary protocol을 갖춘 type-safe 데이터 전송</li>
<li>통합: 네트워크 protocol을 위한 자동 container 직렬화</li>
</ul>
</li>
<li><b><a href="https://github.com/kcenon/database_system">database_system</a></b>: 네트워크 기반 데이터베이스 작업<ul>
<li>사용: 원격 데이터베이스 연결 및 분산 작업</li>
<li>이점: 네트워크 투명 데이터베이스 액세스 및 클러스터링</li>
<li>참조: 네트워크 protocol을 통한 데이터베이스 connection pooling</li>
</ul>
</li>
<li><b><a href="https://github.com/kcenon/thread_system">thread_system</a></b>: 네트워크 작업을 위한 thread 인프라<ul>
<li>관계: 동시 네트워크 작업을 위한 thread pool 관리</li>
<li>이점: 확장 가능한 동시 연결 처리</li>
<li>통합: thread pool 최적화를 통한 비동기 I/O 처리</li>
</ul>
</li>
<li><b><a href="https://github.com/kcenon/logger_system">logger_system</a></b>: 네트워크 로깅 및 진단<ul>
<li>사용: 네트워크 작업 로깅 및 성능 모니터링</li>
<li>이점: 포괄적인 네트워크 진단 및 문제 해결</li>
<li>참조: 네트워크 이벤트 로깅 및 성능 분석</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="autotoc_md451"></a>
통합 아키텍처</h3>
<div class="fragment"><div class="line">┌─────────────────┐     ┌─────────────────┐</div>
<div class="line">│  thread_system  │ ──► │ network_system  │ ◄── Foundation: Async I/O, Connection Management</div>
<div class="line">└─────────────────┘     └─────────┬───────┘</div>
<div class="line">         │                        │ provides transport for</div>
<div class="line">         │                        ▼</div>
<div class="line">┌─────────▼───────┐     ┌─────────────────┐     ┌─────────────────┐</div>
<div class="line">│container_system │ ──► │messaging_system │ ◄──► │database_system  │</div>
<div class="line">└─────────────────┘     └─────────────────┘     └─────────────────┘</div>
<div class="line">         │                        │                       │</div>
<div class="line">         └────────┬───────────────┴───────────────────────┘</div>
<div class="line">                  ▼</div>
<div class="line">    ┌─────────────────────────┐</div>
<div class="line">    │   logger_system        │</div>
<div class="line">    └─────────────────────────┘</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md452"></a>
통합 이점</h3>
<ul>
<li><b>범용 전송 계층</b>: 모든 생태계 구성 요소를 위한 고성능 네트워킹</li>
<li><b>제로 의존성 모듈형 설계</b>: 독립적으로 또는 더 큰 시스템의 일부로 사용 가능</li>
<li><b>하위 호환성</b>: 레거시 messaging_system 통합으로부터 원활한 마이그레이션 경로</li>
<li><b>성능 최적화</b>: 초당 305K+ 메시지 처리량과 마이크로초 미만 지연시간</li>
<li><b>크로스 플랫폼 지원</b>: Windows, Linux, macOS에서 일관된 성능</li>
</ul>
<blockquote class="doxtable">
<p>&zwj;📖 <b>완전한 아키텍처 가이드</b>: 전체 생태계 아키텍처, 의존성 관계 및 통합 패턴에 대한 포괄적인 문서. </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md453"></a>
프로젝트 목적 및 미션</h2>
<p>이 프로젝트는 전 세계 개발자들이 직면한 근본적인 과제를 해결합니다: <b>고성능 네트워크 프로그래밍을 접근 가능하고, 모듈화되고, 신뢰할 수 있게 만드는 것</b>. 전통적인 네트워크 라이브러리는 종종 특정 프레임워크와 긴밀하게 결합되고, 포괄적인 비동기 지원이 부족하며, 높은 처리량 애플리케이션에 대한 불충분한 성능을 제공합니다. 우리의 미션은 다음을 수행하는 포괄적인 솔루션을 제공하는 것입니다:</p>
<ul>
<li><b>긴밀한 결합 제거</b> - 프로젝트 전반에 걸쳐 독립적인 사용을 가능하게 하는 모듈형 설계를 통해</li>
<li><b>성능 극대화</b> - zero-copy pipeline, connection pooling 및 비동기 I/O 최적화를 통해</li>
<li><b>신뢰성 보장</b> - 포괄적인 오류 처리, 연결 수명 주기 관리 및 내결함성을 통해</li>
<li><b>재사용성 촉진</b> - 깨끗한 인터페이스 및 생태계 통합 기능을 통해</li>
<li><b>개발 가속화</b> - 최소한의 설정으로 프로덕션 준비 완료 네트워킹을 제공하여</li>
</ul>
<h2><a class="anchor" id="autotoc_md454"></a>
핵심 장점 및 이점</h2>
<h3><a class="anchor" id="autotoc_md455"></a>
🚀 &lt;strong&gt;성능 우수성&lt;/strong&gt;</h3>
<ul>
<li><b>초고속 처리량</b>: 평균 초당 305K+ 메시지, 작은 메시지의 경우 초당 769K+ 메시지</li>
<li><b>Zero-copy pipeline</b>: 최대 효율성을 위한 직접 메모리 매핑</li>
<li><b>비동기 I/O 최적화</b>: C++20 coroutine을 갖춘 ASIO 기반 논블로킹 작업</li>
<li><b>Connection pooling</b>: 지능적인 연결 재사용 및 수명 주기 관리</li>
</ul>
<h3><a class="anchor" id="autotoc_md456"></a>
🛡️ &lt;strong&gt;프로덕션급 신뢰성&lt;/strong&gt;</h3>
<ul>
<li><b>모듈형 독립성</b>: 표준 라이브러리 이외의 외부 의존성 제로</li>
<li><b>포괄적인 오류 처리</b>: 우아한 성능 저하 및 복구 패턴</li>
<li><b>메모리 안전성</b>: RAII 원칙 및 스마트 포인터가 누수 및 손상을 방지</li>
<li><b>Thread 안전성</b>: 적절한 동기화를 통한 동시 작업</li>
</ul>
<h3><a class="anchor" id="autotoc_md457"></a>
🔧 &lt;strong&gt;개발자 생산성&lt;/strong&gt;</h3>
<ul>
<li><b>직관적인 API 설계</b>: 깨끗하고 자체 문서화된 인터페이스로 학습 곡선 감소</li>
<li><b>하위 호환성</b>: 레거시 messaging_system 코드와 100% 호환</li>
<li><b>풍부한 통합</b>: thread, container 및 logger system과의 원활한 통합</li>
<li><b>최신 C++ 기능</b>: C++20 coroutine, concept 및 range 지원</li>
</ul>
<h3><a class="anchor" id="autotoc_md458"></a>
🌐 &lt;strong&gt;크로스 플랫폼 호환성&lt;/strong&gt;</h3>
<ul>
<li><b>범용 지원</b>: Windows, Linux 및 macOS에서 작동</li>
<li><b>아키텍처 최적화</b>: x86, x64 및 ARM64에 대한 성능 튜닝</li>
<li><b>컴파일러 유연성</b>: GCC, Clang 및 MSVC와 호환</li>
<li><b>Container 지원</b>: 자동화된 CI/CD를 갖춘 Docker 지원</li>
</ul>
<h3><a class="anchor" id="autotoc_md459"></a>
📈 &lt;strong&gt;엔터프라이즈 준비 완료 기능&lt;/strong&gt;</h3>
<ul>
<li><b>Session 관리</b>: 포괄적인 session 수명 주기 및 상태 관리</li>
<li><b>Connection pooling</b>: 상태 모니터링을 갖춘 엔터프라이즈급 연결 관리</li>
<li><b>성능 모니터링</b>: 실시간 메트릭 및 성능 분석</li>
<li><b>마이그레이션 지원</b>: messaging_system 통합으로부터 완전한 마이그레이션 도구</li>
</ul>
<h2><a class="anchor" id="autotoc_md460"></a>
실제 영향 및 사용 사례</h2>
<h3><a class="anchor" id="autotoc_md461"></a>
🎯 &lt;strong&gt;이상적인 애플리케이션&lt;/strong&gt;</h3>
<ul>
<li><b>메시징 시스템</b>: 높은 처리량 메시지 라우팅 및 전달</li>
<li><b>분산 시스템</b>: 서비스 간 통신 및 조정</li>
<li><b>실시간 애플리케이션</b>: 게임, 거래 및 IoT 데이터 스트리밍</li>
<li><b>마이크로서비스</b>: 로드 밸런싱을 갖춘 서비스 간 통신</li>
<li><b>데이터베이스 클러스터링</b>: 데이터베이스 복제 및 분산 쿼리 처리</li>
<li><b>콘텐츠 전달</b>: 고성능 콘텐츠 스트리밍 및 캐싱</li>
</ul>
<h3><a class="anchor" id="autotoc_md462"></a>
📊 &lt;strong&gt;성능 벤치마크&lt;/strong&gt;</h3>
<blockquote class="doxtable">
<p>&zwj;<b>측정 환경</b>: Intel i7-12700K @ 3.8GHz, 32GB RAM, Ubuntu 22.04, GCC 11 with <code>-O3</code> <b>테스트 날짜</b>: 2025-10-09 <b>네트워크</b>: 루프백 인터페이스 (localhost) <b>프레임워크</b>: Google Benchmark 1.8.3 </p>
</blockquote>
<p>모든 성능 주장은 측정되고 재현 가능합니다. 아래 재현 지침을 참조하세요.</p>
<h4><a class="anchor" id="autotoc_md463"></a>
메시지 크기별 처리량 성능</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">메시지 크기   </th><th class="markdownTableHeadNone">처리량   </th><th class="markdownTableHeadNone">지연시간 (P50)   </th><th class="markdownTableHeadNone">최적 사용 사례    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>64 bytes</b>   </td><td class="markdownTableBodyNone"><b>769,230 msg/s</b>   </td><td class="markdownTableBodyNone">&lt;10μs   </td><td class="markdownTableBodyNone">제어 신호, 하트비트    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>256 bytes</b>   </td><td class="markdownTableBodyNone"><b>305,255 msg/s</b>   </td><td class="markdownTableBodyNone">50μs   </td><td class="markdownTableBodyNone">표준 메시지 (평균)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>1 KB</b>   </td><td class="markdownTableBodyNone"><b>128,205 msg/s</b>   </td><td class="markdownTableBodyNone">100μs   </td><td class="markdownTableBodyNone">데이터 패킷    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>8 KB</b>   </td><td class="markdownTableBodyNone"><b>20,833 msg/s</b>   </td><td class="markdownTableBodyNone">500μs   </td><td class="markdownTableBodyNone">대용량 페이로드   </td></tr>
</table>
<p><b>평균 성능</b>: 혼합 작업부하(모든 메시지 크기)에서 305K msg/s</p>
<h4><a class="anchor" id="autotoc_md464"></a>
지연시간 특성</h4>
<ul>
<li><b>P50 (중앙값)</b>: 50 마이크로초</li>
<li><b>P95</b>: 부하 시 500 마이크로초</li>
<li><b>P99</b>: 2 밀리초</li>
<li><b>평균</b>: 모든 메시지 크기에서 584 마이크로초</li>
</ul>
<p><em>참고: 지연시간에는 직렬화, 네트워크 전송 및 역직렬화가 포함됩니다.</em></p>
<h4><a class="anchor" id="autotoc_md465"></a>
동시 성능</h4>
<ul>
<li><b>50개 동시 연결</b>: 12,195 msg/s 안정적인 처리량</li>
<li><b>연결 설정</b>: 연결당 &lt;100μs</li>
<li><b>세션 관리 오버헤드</b>: 세션당 &lt;50μs</li>
</ul>
<h4><a class="anchor" id="autotoc_md466"></a>
메모리 효율성</h4>
<ul>
<li><b>기준선</b> (유휴 서버): &lt;10 MB</li>
<li>**50개 활성 연결**: 45 MB</li>
<li>**연결 풀링**: 효율적인 리소스 재사용</li>
</ul>
<h4><a class="anchor" id="autotoc_md467"></a>
주요 성능 인사이트</h4>
<ul>
<li>🏃 **확장 가능한 처리량**: 메시지 크기와 작업부하에 따라 성능 확장</li>
<li>🏋️ **동시 처리**: 여러 연결에서 안정적인 성능</li>
<li>⏱️ **낮은 지연시간**: 50마이크로초 미만의 중앙값 지연시간 (P50)</li>
<li>📈 **메모리 효율성**: 지능형 풀링을 통한 최소 기준선 풋프린트</li>
</ul>
<h4><a class="anchor" id="autotoc_md468"></a>
🔬 벤치마크 재현하기</h4>
<p>모든 성능 측정은 독립적으로 검증 가능합니다:</p>
<div class="fragment"><div class="line"># 1단계: 벤치마크를 활성화하여 빌드</div>
<div class="line">git clone https://github.com/kcenon/network_system.git</div>
<div class="line">cd network_system</div>
<div class="line">cmake -B build -DCMAKE_BUILD_TYPE=Release -DNETWORK_BUILD_BENCHMARKS=ON</div>
<div class="line">cmake --build build -j</div>
<div class="line"> </div>
<div class="line"># 2단계: 벤치마크 실행</div>
<div class="line">./build/benchmarks/network_benchmarks</div>
<div class="line"> </div>
<div class="line"># 3단계: 분석을 위한 JSON 출력 생성</div>
<div class="line">./build/benchmarks/network_benchmarks --benchmark_format=json --benchmark_out=results.json</div>
<div class="line"> </div>
<div class="line"># 4단계: 특정 벤치마크 카테고리 실행</div>
<div class="line">./build/benchmarks/network_benchmarks --benchmark_filter=MessageThroughput</div>
<div class="line">./build/benchmarks/network_benchmarks --benchmark_filter=Connection</div>
<div class="line">./build/benchmarks/network_benchmarks --benchmark_filter=Session</div>
</div><!-- fragment --><p>**예상 출력** (Intel i7-12700K, Ubuntu 22.04): </p><div class="fragment"><div class="line">-------------------------------------------------------------------------</div>
<div class="line">Benchmark                               Time       CPU   Iterations</div>
<div class="line">-------------------------------------------------------------------------</div>
<div class="line">MessageThroughput/64B            1300 ns   1299 ns       538462   # ~769K msg/s</div>
<div class="line">MessageThroughput/256B           3270 ns   3268 ns       214286   # ~305K msg/s</div>
<div class="line">MessageThroughput/1KB            7803 ns   7801 ns        89744   # ~128K msg/s</div>
<div class="line">MessageThroughput/8KB           48000 ns  47998 ns        14583   # ~21K msg/s</div>
</div><!-- fragment --><p>**참고**: 성능은 하드웨어에 따라 다릅니다. 정확한 평가를 위해 대상 시스템에서 벤치마크를 실행하세요.</p>
<h4><a class="anchor" id="autotoc_md469"></a>
성능 비교 참고사항</h4>
<p>우리는 자체 시스템의 검증된 측정값을 제공합니다. 다른 라이브러리와 비교하려면:</p>
<ul>
<li>✅ **우리의 측정값**은 실제 벤치마크 실행을 기반으로 합니다 (위 참조)</li>
<li>⚠️ **타사 라이브러리 비교**는 귀하의 환경에서 수행해야 합니다</li>
<li>📊 **공정한 비교**를 위해 동일한 하드웨어, OS, 컴파일러 설정을 사용하세요</li>
<li>🔬 사용자는 벤치마크를 실행하여 특정 사용 사례에 가장 적합한 것을 결정할 수 있습니다</li>
</ul>
<p>자세한 성능 메트릭은 [BASELINE.md](BASELINE.md)를 참조하세요.</p>
<h3><a class="anchor" id="autotoc_md470"></a>
핵심 목표</h3>
<ul>
<li>**모듈 독립성**: messaging_system으로부터 네트워크 모듈의 완전한 분리 ✅</li>
<li>**향상된 재사용성**: 다른 프로젝트에서 사용 가능한 독립적인 라이브러리 ✅</li>
<li>**호환성 유지**: 레거시 코드와의 완전한 하위 호환성 ✅</li>
<li>**성능 최적화**: 초당 305K+ 메시지 처리량 달성 ✅</li>
</ul>
<h2><a class="anchor" id="autotoc_md471"></a>
🛠️ 기술 스택 및 아키텍처</h2>
<h3><a class="anchor" id="autotoc_md472"></a>
핵심 기술</h3>
<ul>
<li>**C++20**: concept, coroutine 및 range를 포함한 최신 C++ 기능</li>
<li>**Asio**: 고성능 크로스 플랫폼 네트워킹 라이브러리</li>
<li>**CMake**: 포괄적인 의존성 관리를 갖춘 빌드 시스템</li>
<li>**크로스 플랫폼**: Windows, Linux 및 macOS에 대한 기본 지원</li>
</ul>
<h3><a class="anchor" id="autotoc_md473"></a>
아키텍처 설계</h3>
<div class="fragment"><div class="line">┌─────────────────────────────────────────────────────────────┐</div>
<div class="line">│                    Network System Architecture              │</div>
<div class="line">├─────────────────────────────────────────────────────────────┤</div>
<div class="line">│  공개 API 계층                                               │</div>
<div class="line">│  ┌──────────────────────┐  ┌──────────────────────┐        │</div>
<div class="line">│  │  messaging_server    │  │  messaging_client    │        │</div>
<div class="line">│  │  (TCP Server)        │  │  (TCP Client)        │        │</div>
<div class="line">│  └──────────────────────┘  └──────────────────────┘        │</div>
<div class="line">├─────────────────────────────────────────────────────────────┤</div>
<div class="line">│  내부 계층                                                   │</div>
<div class="line">│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐           │</div>
<div class="line">│  │ tcp_socket  │ │  messaging  │ │  pipeline   │           │</div>
<div class="line">│  │             │ │  _session   │ │             │           │</div>
<div class="line">│  └─────────────┘ └─────────────┘ └─────────────┘           │</div>
<div class="line">├─────────────────────────────────────────────────────────────┤</div>
<div class="line">│  핵심 네트워크 엔진 (ASIO 기반)                             │</div>
<div class="line">│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐           │</div>
<div class="line">│  │ io_context  │ │   async     │ │  Result&lt;T&gt;  │           │</div>
<div class="line">│  │             │ │  operations │ │   pattern   │           │</div>
<div class="line">│  └─────────────┘ └─────────────┘ └─────────────┘           │</div>
<div class="line">├─────────────────────────────────────────────────────────────┤</div>
<div class="line">│  선택적 통합 계층                                            │</div>
<div class="line">│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐           │</div>
<div class="line">│  │   Logger    │ │ Monitoring  │ │   Thread    │           │</div>
<div class="line">│  │  System     │ │   System    │ │   System    │           │</div>
<div class="line">│  └─────────────┘ └─────────────┘ └─────────────┘           │</div>
<div class="line">└─────────────────────────────────────────────────────────────┘</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md474"></a>
디자인 패턴</h3>
<ul>
<li><b>Factory Pattern</b>: 네트워크 구성 요소 생성 및 구성</li>
<li><b>Observer Pattern</b>: 이벤트 기반 네트워크 상태 관리</li>
<li><b>Strategy Pattern</b>: 플러그 가능한 protocol 구현</li>
<li><b>RAII</b>: 연결을 위한 자동 리소스 관리</li>
<li><b>Template Metaprogramming</b>: 컴파일 타임 protocol 최적화</li>
</ul>
<h2><a class="anchor" id="autotoc_md475"></a>
📁 프로젝트 구조</h2>
<h3><a class="anchor" id="autotoc_md476"></a>
디렉토리 구성</h3>
<div class="fragment"><div class="line">network_system/</div>
<div class="line">├── 📁 include/network_system/   # 공개 헤더 파일</div>
<div class="line">│   ├── 📁 core/                 # 핵심 구성 요소</div>
<div class="line">│   │   ├── messaging_server.h   # TCP 서버 구현</div>
<div class="line">│   │   └── messaging_client.h   # TCP 클라이언트 구현</div>
<div class="line">│   ├── 📁 internal/             # 내부 구현</div>
<div class="line">│   │   ├── tcp_socket.h         # 소켓 래퍼</div>
<div class="line">│   │   ├── messaging_session.h  # 세션 처리</div>
<div class="line">│   │   └── pipeline.h           # 데이터 처리 파이프라인</div>
<div class="line">│   └── 📁 utils/                # 유틸리티</div>
<div class="line">│       └── result_types.h       # Result&lt;T&gt; 오류 처리</div>
<div class="line">├── 📁 src/                      # 구현 파일</div>
<div class="line">│   ├── 📁 core/                 # 핵심 구현</div>
<div class="line">│   ├── 📁 internal/             # 내부 구현</div>
<div class="line">│   └── 📁 utils/                # 유틸리티 구현</div>
<div class="line">├── 📁 samples/                  # 사용 예제</div>
<div class="line">│   └── basic_usage.cpp          # 기본 TCP 예제</div>
<div class="line">├── 📁 benchmarks/               # 성능 벤치마크</div>
<div class="line">│   └── CMakeLists.txt           # 벤치마크 빌드 설정</div>
<div class="line">├── 📁 docs/                     # 문서</div>
<div class="line">│   └── BASELINE.md              # 성능 기준선</div>
<div class="line">├── 📄 CMakeLists.txt            # 빌드 설정</div>
<div class="line">├── 📄 .clang-format             # 코드 포매팅 규칙</div>
<div class="line">└── 📄 README.md                 # 이 파일</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md477"></a>
🚀 빠른 시작 및 사용 예제</h2>
<h3><a class="anchor" id="autotoc_md478"></a>
5분 안에 시작하기</h3>
<p><b>1단계: 빠른 설치</b> </p><div class="fragment"><div class="line"># Clone and build</div>
<div class="line">git clone https://github.com/kcenon/network_system.git</div>
<div class="line">cd network_system &amp;&amp; mkdir build &amp;&amp; cd build</div>
<div class="line">cmake .. -G Ninja -DCMAKE_BUILD_TYPE=Release &amp;&amp; cmake --build .</div>
</div><!-- fragment --><p><b>2단계: 첫 번째 TCP Server (60초)</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;network_system/core/messaging_server.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// 서버 ID로 TCP 서버 생성</span></div>
<div class="line">    <span class="keyword">auto</span> server = std::make_shared&lt;network_system::core::messaging_server&gt;(<span class="stringliteral">&quot;MyServer&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 포트 8080에서 서버 시작</span></div>
<div class="line">    <span class="keyword">auto</span> result = server-&gt;start_server(8080);</div>
<div class="line">    <span class="keywordflow">if</span> (!result) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;서버 시작 실패: &quot;</span> &lt;&lt; result.error().message &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> -1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;서버가 포트 8080에서 실행 중...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;종료하려면 Ctrl+C를 누르세요&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 서버가 중지될 때까지 대기</span></div>
<div class="line">    server-&gt;wait_for_stop();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>3단계: TCP Client로 연결</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;network_system/core/messaging_client.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cstring&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;thread&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;chrono&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// 클라이언트 ID로 TCP 클라이언트 생성</span></div>
<div class="line">    <span class="keyword">auto</span> client = std::make_shared&lt;network_system::core::messaging_client&gt;(<span class="stringliteral">&quot;MyClient&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 클라이언트 시작 및 서버에 연결</span></div>
<div class="line">    <span class="keyword">auto</span> result = client-&gt;start_client(<span class="stringliteral">&quot;localhost&quot;</span>, 8080);</div>
<div class="line">    <span class="keywordflow">if</span> (!result) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;연결 실패: &quot;</span> &lt;&lt; result.error().message &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> -1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 연결이 설정될 때까지 대기</span></div>
<div class="line">    std::this_thread::sleep_for(std::chrono::milliseconds(100));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 메시지 전송 (zero-copy를 위해 std::move 필요)</span></div>
<div class="line">    std::string message = <span class="stringliteral">&quot;안녕하세요, Network System!&quot;</span>;</div>
<div class="line">    std::vector&lt;uint8_t&gt; data(message.begin(), message.end());</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> send_result = client-&gt;send_packet(std::move(data));</div>
<div class="line">    <span class="keywordflow">if</span> (!send_result) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;전송 실패: &quot;</span> &lt;&lt; send_result.error().message &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 처리 대기</span></div>
<div class="line">    client-&gt;wait_for_stop();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md479"></a>
전제 조건</h3>
<h4><a class="anchor" id="autotoc_md480"></a>
Ubuntu/Debian</h4>
<div class="fragment"><div class="line">sudo apt update</div>
<div class="line">sudo apt install -y cmake ninja-build libasio-dev libfmt-dev</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md481"></a>
macOS</h4>
<div class="fragment"><div class="line">brew install cmake ninja asio fmt</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md482"></a>
Windows (MSYS2)</h4>
<div class="fragment"><div class="line">pacman -S mingw-w64-x86_64-cmake mingw-w64-x86_64-ninja \</div>
<div class="line">          mingw-w64-x86_64-asio mingw-w64-x86_64-fmt</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md483"></a>
빌드 지침</h3>
<div class="fragment"><div class="line"># 저장소 복제</div>
<div class="line">git clone https://github.com/kcenon/network_system.git</div>
<div class="line">cd network_system</div>
<div class="line"> </div>
<div class="line"># 빌드 디렉토리 생성</div>
<div class="line">mkdir build &amp;&amp; cd build</div>
<div class="line"> </div>
<div class="line"># CMake로 구성 (기본 빌드)</div>
<div class="line">cmake .. -G Ninja -DCMAKE_BUILD_TYPE=Release</div>
<div class="line"> </div>
<div class="line"># 벤치마크를 활성화하여 빌드</div>
<div class="line">cmake .. -G Ninja \</div>
<div class="line">    -DCMAKE_BUILD_TYPE=Release \</div>
<div class="line">    -DNETWORK_BUILD_BENCHMARKS=ON</div>
<div class="line"> </div>
<div class="line"># 선택적 통합과 함께 빌드</div>
<div class="line">cmake .. -G Ninja \</div>
<div class="line">    -DCMAKE_BUILD_TYPE=Release \</div>
<div class="line">    -DBUILD_WITH_THREAD_SYSTEM=ON \</div>
<div class="line">    -DBUILD_WITH_LOGGER_SYSTEM=ON</div>
<div class="line"> </div>
<div class="line"># 빌드</div>
<div class="line">cmake --build .</div>
<div class="line"> </div>
<div class="line"># 벤치마크 실행 (활성화된 경우)</div>
<div class="line">./build/benchmarks/network_benchmarks</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md484"></a>
📝 API 예제</h2>
<h3><a class="anchor" id="autotoc_md485"></a>
최신 API 사용법</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;network_system/core/messaging_server.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;network_system/core/messaging_client.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 오류 처리를 포함한 서버 예제</span></div>
<div class="line"><span class="keyword">auto</span> server = std::make_shared&lt;network_system::core::messaging_server&gt;(<span class="stringliteral">&quot;server_id&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> server_result = server-&gt;start_server(8080);</div>
<div class="line"><span class="keywordflow">if</span> (!server_result) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;서버 실패: &quot;</span> &lt;&lt; server_result.error().message &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> -1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 오류 처리를 포함한 클라이언트 예제</span></div>
<div class="line"><span class="keyword">auto</span> client = std::make_shared&lt;network_system::core::messaging_client&gt;(<span class="stringliteral">&quot;client_id&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> client_result = client-&gt;start_client(<span class="stringliteral">&quot;localhost&quot;</span>, 8080);</div>
<div class="line"><span class="keywordflow">if</span> (!client_result) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;클라이언트 실패: &quot;</span> &lt;&lt; client_result.error().message &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> -1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 메시지 전송 (zero-copy를 위해 std::move 필요)</span></div>
<div class="line">std::vector&lt;uint8_t&gt; data = {<span class="charliteral">&#39;H&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, <span class="charliteral">&#39;l&#39;</span>, <span class="charliteral">&#39;l&#39;</span>, <span class="charliteral">&#39;o&#39;</span>};</div>
<div class="line"><span class="keyword">auto</span> send_result = client-&gt;send_packet(std::move(data));</div>
<div class="line"><span class="keywordflow">if</span> (!send_result) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;전송 실패: &quot;</span> &lt;&lt; send_result.error().message &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md486"></a>
레거시 API 호환성</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;network_system/compatibility.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Use legacy namespace - fully compatible</span></div>
<div class="line"><span class="keyword">auto</span> server = network_module::create_server(<span class="stringliteral">&quot;legacy_server&quot;</span>);</div>
<div class="line">server-&gt;start_server(8080);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> client = network_module::create_client(<span class="stringliteral">&quot;legacy_client&quot;</span>);</div>
<div class="line">client-&gt;start_client(<span class="stringliteral">&quot;127.0.0.1&quot;</span>, 8080);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md487"></a>
🏗️ 아키텍처</h2>
<div class="fragment"><div class="line">network_system/</div>
<div class="line">├── include/network_system/</div>
<div class="line">│   ├── core/                    # Core networking components</div>
<div class="line">│   │   ├── messaging_client.h</div>
<div class="line">│   │   └── messaging_server.h</div>
<div class="line">│   ├── session/                 # Session management</div>
<div class="line">│   │   └── messaging_session.h</div>
<div class="line">│   ├── internal/                # Internal implementation</div>
<div class="line">│   │   ├── tcp_socket.h</div>
<div class="line">│   │   ├── pipeline.h</div>
<div class="line">│   │   └── send_coroutine.h</div>
<div class="line">│   ├── integration/             # External system integration</div>
<div class="line">│   │   ├── messaging_bridge.h</div>
<div class="line">│   │   ├── thread_integration.h</div>
<div class="line">│   │   ├── container_integration.h</div>
<div class="line">│   │   └── logger_integration.h</div>
<div class="line">│   └── compatibility.h         # Legacy API support</div>
<div class="line">├── src/                        # Implementation files</div>
<div class="line">├── samples/                    # Usage examples</div>
<div class="line">├── tests/                      # Test suites</div>
<div class="line">└── docs/                       # Documentation</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md488"></a>
📚 API 문서</h2>
<h3><a class="anchor" id="autotoc_md489"></a>
빠른 API 참조</h3>
<h4><a class="anchor" id="autotoc_md490"></a>
TCP Server</h4>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;network_system/core/messaging_server.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 식별자로 서버 생성</span></div>
<div class="line"><span class="keyword">auto</span> server = std::make_shared&lt;network_system::core::messaging_server&gt;(<span class="stringliteral">&quot;MyServer&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 특정 포트에서 서버 시작</span></div>
<div class="line"><span class="keyword">auto</span> result = server-&gt;start_server(8080);</div>
<div class="line"><span class="keywordflow">if</span> (!result) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;시작 실패: &quot;</span> &lt;&lt; result.error().message &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> -1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 서버 제어</span></div>
<div class="line">server-&gt;wait_for_stop();                      <span class="comment">// 블로킹 대기</span></div>
<div class="line">server-&gt;stop_server();                        <span class="comment">// 우아한 종료</span></div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md491"></a>
TCP Client</h4>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;network_system/core/messaging_client.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 식별자로 클라이언트 생성</span></div>
<div class="line"><span class="keyword">auto</span> client = std::make_shared&lt;network_system::core::messaging_client&gt;(<span class="stringliteral">&quot;MyClient&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 서버에 연결</span></div>
<div class="line"><span class="keyword">auto</span> result = client-&gt;start_client(<span class="stringliteral">&quot;hostname&quot;</span>, 8080);</div>
<div class="line"><span class="keywordflow">if</span> (!result) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;연결 실패: &quot;</span> &lt;&lt; result.error().message &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> -1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 데이터 전송 (zero-copy를 위해 std::move 필요)</span></div>
<div class="line">std::vector&lt;uint8_t&gt; data = {0x01, 0x02, 0x03};</div>
<div class="line"><span class="keyword">auto</span> send_result = client-&gt;send_packet(std::move(data));</div>
<div class="line"><span class="keywordflow">if</span> (!send_result) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;전송 실패: &quot;</span> &lt;&lt; send_result.error().message &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 연결 상태 확인</span></div>
<div class="line"><span class="keywordflow">if</span> (client-&gt;is_connected()) {</div>
<div class="line">    <span class="comment">// 클라이언트가 연결됨</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 연결 해제</span></div>
<div class="line">client-&gt;stop_client();</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md492"></a>
Result&lt;T&gt;를 사용한 오류 처리</h4>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;network_system/utils/result_types.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Result 기반 오류 처리 (예외 없음)</span></div>
<div class="line"><span class="keyword">auto</span> result = client-&gt;start_client(<span class="stringliteral">&quot;hostname&quot;</span>, 8080);</div>
<div class="line"><span class="keywordflow">if</span> (!result) {</div>
<div class="line">    <span class="comment">// 오류 세부 정보 액세스</span></div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;오류 코드: &quot;</span> &lt;&lt; <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(result.error().code) &lt;&lt; std::endl;</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;오류 메시지: &quot;</span> &lt;&lt; result.error().message &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> -1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 오류 검사가 포함된 전송 작업</span></div>
<div class="line">std::vector&lt;uint8_t&gt; data = {0x01, 0x02, 0x03};</div>
<div class="line"><span class="keyword">auto</span> send_result = client-&gt;send_packet(std::move(data));</div>
<div class="line"><span class="keywordflow">if</span> (!send_result) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;전송 실패: &quot;</span> &lt;&lt; send_result.error().message &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 연결 상태 확인</span></div>
<div class="line"><span class="keywordflow">if</span> (client-&gt;is_connected()) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;클라이언트가 연결되었습니다&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;클라이언트가 연결 해제되었습니다&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md493"></a>
Zero-Copy 데이터 전송</h4>
<div class="fragment"><div class="line"><span class="comment">// zero-copy 작업을 위한 이동 의미론</span></div>
<div class="line">std::vector&lt;uint8_t&gt; large_buffer(1024 * 1024); <span class="comment">// 1 MB</span></div>
<div class="line"><span class="comment">// ... 버퍼에 데이터 채우기 ...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 데이터가 복사되지 않고 이동됨 - 대용량 페이로드에 효율적</span></div>
<div class="line"><span class="keyword">auto</span> result = client-&gt;send_packet(std::move(large_buffer));</div>
<div class="line"><span class="comment">// large_buffer는 이동 후 비어 있음</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (!result) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;전송 실패: &quot;</span> &lt;&lt; result.error().message &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md494"></a>
오류 처리 및 진단</h4>
<div class="fragment"><div class="line"><span class="comment">// Comprehensive error handling</span></div>
<div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">    client.connect();</div>
<div class="line">    client.send(<span class="stringliteral">&quot;data&quot;</span>);</div>
<div class="line">} <span class="keywordflow">catch</span> (<span class="keyword">const</span> network::connection_error&amp; e) {</div>
<div class="line">    <span class="comment">// Connection-specific errors</span></div>
<div class="line">    log_error(<span class="stringliteral">&quot;Connection failed: &quot;</span>, e.what());</div>
<div class="line">} <span class="keywordflow">catch</span> (<span class="keyword">const</span> network::timeout_error&amp; e) {</div>
<div class="line">    <span class="comment">// Timeout-specific errors</span></div>
<div class="line">    log_error(<span class="stringliteral">&quot;Operation timed out: &quot;</span>, e.what());</div>
<div class="line">} <span class="keywordflow">catch</span> (<span class="keyword">const</span> network::protocol_error&amp; e) {</div>
<div class="line">    <span class="comment">// Protocol-specific errors</span></div>
<div class="line">    log_error(<span class="stringliteral">&quot;Protocol error: &quot;</span>, e.what());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Performance diagnostics</span></div>
<div class="line"><span class="keyword">auto</span> stats = server.get_statistics();</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Connections: &quot;</span> &lt;&lt; stats.active_connections &lt;&lt; std::endl;</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Messages/sec: &quot;</span> &lt;&lt; stats.messages_per_second &lt;&lt; std::endl;</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Bytes/sec: &quot;</span> &lt;&lt; stats.bytes_per_second &lt;&lt; std::endl;</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Avg latency: &quot;</span> &lt;&lt; stats.average_latency &lt;&lt; <span class="stringliteral">&quot;ms&quot;</span> &lt;&lt; std::endl;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md495"></a>
📊 성능 벤치마크</h2>
<h3><a class="anchor" id="autotoc_md496"></a>
최신 결과</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">메트릭   </th><th class="markdownTableHeadNone">결과   </th><th class="markdownTableHeadNone">테스트 조건    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>평균 처리량</b>   </td><td class="markdownTableBodyNone">305,255 msg/s   </td><td class="markdownTableBodyNone">혼합 메시지 크기    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>작은 메시지 (64B)</b>   </td><td class="markdownTableBodyNone">769,230 msg/s   </td><td class="markdownTableBodyNone">10,000 메시지    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>중간 메시지 (1KB)</b>   </td><td class="markdownTableBodyNone">128,205 msg/s   </td><td class="markdownTableBodyNone">5,000 메시지    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>큰 메시지 (8KB)</b>   </td><td class="markdownTableBodyNone">20,833 msg/s   </td><td class="markdownTableBodyNone">1,000 메시지    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>동시 연결</b>   </td><td class="markdownTableBodyNone">50 clients   </td><td class="markdownTableBodyNone">12,195 msg/s    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>평균 지연시간</b>   </td><td class="markdownTableBodyNone">584.22 μs   </td><td class="markdownTableBodyNone">P50: &lt; 50 μs    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>성능 등급</b>   </td><td class="markdownTableBodyNone">🏆 EXCELLENT   </td><td class="markdownTableBodyNone">프로덕션 준비 완료!   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md497"></a>
주요 성능 기능</h3>
<ul>
<li>Zero-copy 메시지 pipeline</li>
<li>가능한 경우 Lock-free 데이터 구조</li>
<li>Connection pooling</li>
<li>ASIO를 사용한 비동기 I/O</li>
<li>C++20 coroutine 지원</li>
</ul>
<h2><a class="anchor" id="autotoc_md498"></a>
🔧 기능</h2>
<h3><a class="anchor" id="autotoc_md499"></a>
핵심 기능</h3>
<ul>
<li>✅ 비동기 TCP server/client</li>
<li>✅ 멀티스레드 메시지 처리</li>
<li>✅ Session 수명 주기 관리</li>
<li>✅ 버퍼링을 갖춘 메시지 pipeline</li>
<li>✅ C++20 coroutine 지원</li>
</ul>
<h3><a class="anchor" id="autotoc_md500"></a>
통합 기능</h3>
<ul>
<li>✅ Thread pool 통합</li>
<li>✅ Container 직렬화 지원</li>
<li>✅ Logger system 통합</li>
<li>✅ 레거시 API 호환성 계층</li>
<li>✅ 포괄적인 테스트 커버리지</li>
<li>✅ 성능 벤치마킹 suite</li>
</ul>
<h3><a class="anchor" id="autotoc_md501"></a>
계획된 기능</h3>
<ul>
<li>🚧 WebSocket 지원</li>
<li>🚧 TLS/SSL 암호화</li>
<li>🚧 HTTP/2 client</li>
<li>🚧 gRPC 통합</li>
</ul>
<h2><a class="anchor" id="autotoc_md502"></a>
🎯 프로젝트 요약</h2>
<p>Network System은 향상된 모듈성과 재사용성을 제공하기 위해 messaging_system에서 성공적으로 분리된 <b>프로덕션 준비 완료</b> 고성능 비동기 네트워크 라이브러리입니다.</p>
<h3><a class="anchor" id="autotoc_md503"></a>
🏆 주요 성과</h3>
<h4><a class="anchor" id="autotoc_md504"></a>
&lt;strong&gt;완전한 독립성&lt;/strong&gt; ✅</h4>
<ul>
<li>messaging_system으로부터 제로 의존성으로 완전히 분리</li>
<li>모든 C++ 프로젝트에 통합하기에 적합한 독립적인 라이브러리</li>
<li>깨끗한 namespace 격리 (<code>network_system::</code>)</li>
</ul>
<h4><a class="anchor" id="autotoc_md505"></a>
&lt;strong&gt;하위 호환성&lt;/strong&gt; ✅</h4>
<ul>
<li>기존 messaging_system 코드와 100% 호환</li>
<li>호환성 계층을 통한 원활한 마이그레이션 경로</li>
<li>레거시 API 지원 유지 (<code>network_module::</code>)</li>
</ul>
<h4><a class="anchor" id="autotoc_md506"></a>
&lt;strong&gt;성능 우수성&lt;/strong&gt; ✅</h4>
<ul>
<li>평균 처리량 <b>초당 305K+ 메시지</b></li>
<li>작은 메시지 (64바이트)에 대해 <b>초당 769K+ 메시지</b></li>
<li>50마이크로초 미만 중앙값 지연시간 (P50)</li>
<li>50개 이상의 동시 연결로 프로덕션 테스트 완료</li>
</ul>
<h4><a class="anchor" id="autotoc_md507"></a>
&lt;strong&gt;통합 생태계&lt;/strong&gt; ✅</h4>
<ul>
<li><b>Thread System 통합</b>: 원활한 thread pool 관리</li>
<li><b>Logger System 통합</b>: 포괄적인 로깅 기능</li>
<li><b>Container System 통합</b>: 고급 직렬화 지원</li>
<li><b>크로스 플랫폼 지원</b>: Ubuntu, Windows, macOS 호환성</li>
</ul>
<h3><a class="anchor" id="autotoc_md508"></a>
🚀 마이그레이션 상태</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">구성 요소   </th><th class="markdownTableHeadNone">상태   </th><th class="markdownTableHeadNone">비고    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>핵심 네트워크 라이브러리</b>   </td><td class="markdownTableBodyNone">✅ 완료   </td><td class="markdownTableBodyNone">독립적, 프로덕션 준비 완료    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>레거시 API 호환성</b>   </td><td class="markdownTableBodyNone">✅ 완료   </td><td class="markdownTableBodyNone">제로 중단 변경    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>성능 최적화</b>   </td><td class="markdownTableBodyNone">✅ 완료   </td><td class="markdownTableBodyNone">초당 305K+ 메시지 달성    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>통합 인터페이스</b>   </td><td class="markdownTableBodyNone">✅ 완료   </td><td class="markdownTableBodyNone">Thread, Logger, Container system    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>문서</b>   </td><td class="markdownTableBodyNone">✅ 완료   </td><td class="markdownTableBodyNone">API 문서, 가이드, 예제    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>CI/CD Pipeline</b>   </td><td class="markdownTableBodyNone">✅ 완료   </td><td class="markdownTableBodyNone">멀티 플랫폼 자동화 테스트   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md509"></a>
📊 영향 및 이점</h3>
<ul>
<li><b>모듈성</b>: 독립적인 라이브러리는 결합을 줄이고 유지보수성을 향상시킴</li>
<li><b>재사용성</b>: messaging_system을 넘어 여러 프로젝트에 통합 가능</li>
<li><b>성능</b>: 레거시 구현에 비해 상당한 처리량 개선</li>
<li><b>호환성</b>: 기존 애플리케이션을 위한 제로 다운타임 마이그레이션 경로</li>
<li><b>품질</b>: 포괄적인 테스트 커버리지 및 지속적인 통합</li>
</ul>
<h2><a class="anchor" id="autotoc_md510"></a>
🔧 의존성</h2>
<h3><a class="anchor" id="autotoc_md511"></a>
필수</h3>
<ul>
<li><b>C++20</b> 호환 컴파일러</li>
<li><b>CMake</b> 3.16+</li>
<li><b>ASIO</b> 또는 <b>Boost.ASIO</b> 1.28+</li>
</ul>
<h3><a class="anchor" id="autotoc_md512"></a>
선택 사항</h3>
<ul>
<li><b>fmt</b> 10.0+ (std::format으로 대체 가능)</li>
<li><b>container_system</b> (고급 직렬화용)</li>
<li><b>thread_system</b> (thread pool 통합용)</li>
<li><b>logger_system</b> (구조화된 로깅용)</li>
</ul>
<h2><a class="anchor" id="autotoc_md513"></a>
🎯 플랫폼 지원</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">플랫폼   </th><th class="markdownTableHeadNone">컴파일러   </th><th class="markdownTableHeadNone">아키텍처   </th><th class="markdownTableHeadNone">지원 수준    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Ubuntu 22.04+   </td><td class="markdownTableBodyNone">GCC 11+   </td><td class="markdownTableBodyNone">x86_64   </td><td class="markdownTableBodyNone">✅ 완전 지원    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Ubuntu 22.04+   </td><td class="markdownTableBodyNone">Clang 14+   </td><td class="markdownTableBodyNone">x86_64   </td><td class="markdownTableBodyNone">✅ 완전 지원    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Windows 2022+   </td><td class="markdownTableBodyNone">MSVC 2022+   </td><td class="markdownTableBodyNone">x86_64   </td><td class="markdownTableBodyNone">✅ 완전 지원    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Windows 2022+   </td><td class="markdownTableBodyNone">MinGW64   </td><td class="markdownTableBodyNone">x86_64   </td><td class="markdownTableBodyNone">✅ 완전 지원    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">macOS 12+   </td><td class="markdownTableBodyNone">Apple Clang 14+   </td><td class="markdownTableBodyNone">x86_64/ARM64   </td><td class="markdownTableBodyNone">🚧 실험적   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md514"></a>
📚 문서</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">문서   </th><th class="markdownTableHeadNone">설명    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://kcenon.github.io/network_system">API Reference</a>   </td><td class="markdownTableBodyNone">Doxygen 생성 API 문서    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Migration Guide   </td><td class="markdownTableBodyNone">messaging_system으로부터 단계별 마이그레이션    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="md_BASELINE.html">Performance Baseline</a>   </td><td class="markdownTableBodyNone">검증된 성능 측정값   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md515"></a>
🤝 기여</h2>
<p>기여를 환영합니다! 다음 가이드라인을 따라주세요:</p>
<ol type="1">
<li>저장소를 Fork하세요</li>
<li>기능 브랜치를 생성하세요 (<code>git checkout -b feature/amazing-feature</code>)</li>
<li>기존 커밋 규칙에 따라 변경 사항을 커밋하세요</li>
<li>브랜치에 푸시하세요 (<code>git push origin feature/amazing-feature</code>)</li>
<li>Pull Request를 여세요</li>
</ol>
<h2><a class="anchor" id="autotoc_md516"></a>
📄 라이선스</h2>
<p>이 프로젝트는 BSD-3-Clause License에 따라 라이선스가 부여됩니다 - 자세한 내용은 [LICENSE](LICENSE) 파일을 참조하세요.</p>
<h2><a class="anchor" id="autotoc_md517"></a>
🙏 감사의 말</h2>
<h3><a class="anchor" id="autotoc_md518"></a>
핵심 의존성</h3>
<ul>
<li><b>ASIO Library Team</b>: C++에서 비동기 네트워크 프로그래밍의 기초 제공</li>
<li><b>fmt Library Contributors</b>: 최신의 안전하고 빠른 포맷팅 기능 제공</li>
<li><b>C++ Standards Committee</b>: 최신 네트워킹을 가능하게 하는 C++20 기능 제공</li>
</ul>
<h3><a class="anchor" id="autotoc_md519"></a>
생태계 통합</h3>
<ul>
<li><b>Thread System</b>: 원활한 thread pool 통합 및 멀티스레드 아키텍처</li>
<li><b>Logger System</b>: 포괄적인 로깅 및 디버깅 기능</li>
<li><b>Container System</b>: 고급 직렬화 및 데이터 container 지원</li>
<li><b>Database System</b>: 네트워크-데이터베이스 통합 패턴</li>
<li><b>Monitoring System</b>: 성능 메트릭 및 관찰 가능성 기능</li>
</ul>
<h3><a class="anchor" id="autotoc_md520"></a>
감사의 말</h3>
<ul>
<li>최신 네트워크 프로그래밍 패턴과 모범 사례에서 영감을 받았습니다</li>
<li>관리자: <a href="#" onclick="location.href='mai'+'lto:'+'kce'+'no'+'n@n'+'av'+'er.'+'co'+'m'; return false;">kceno<span class="obfuscator">.nosp@m.</span>n@na<span class="obfuscator">.nosp@m.</span>ver.c<span class="obfuscator">.nosp@m.</span>om</a></li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md522"></a>
📧 연락처 및 지원</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">연락처 유형   </th><th class="markdownTableHeadNone">세부 정보    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>프로젝트 소유자</b>   </td><td class="markdownTableBodyNone">kcenon (<a href="#" onclick="location.href='mai'+'lto:'+'kce'+'no'+'n@n'+'av'+'er.'+'co'+'m'; return false;">kceno<span class="obfuscator">.nosp@m.</span>n@na<span class="obfuscator">.nosp@m.</span>ver.c<span class="obfuscator">.nosp@m.</span>om</a>)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>저장소</b>   </td><td class="markdownTableBodyNone"><a href="https://github.com/kcenon/network_system">https://github.com/kcenon/network_system</a>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>이슈 및 버그 보고</b>   </td><td class="markdownTableBodyNone"><a href="https://github.com/kcenon/network_system/issues">https://github.com/kcenon/network_system/issues</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>토론 및 질문</b>   </td><td class="markdownTableBodyNone"><a href="https://github.com/kcenon/network_system/discussions">https://github.com/kcenon/network_system/discussions</a>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>보안 문제</b>   </td><td class="markdownTableBodyNone"><a href="#" onclick="location.href='mai'+'lto:'+'sec'+'ur'+'ity'+'@n'+'etw'+'or'+'k-s'+'ys'+'tem'+'.d'+'ev'; return false;">secur<span class="obfuscator">.nosp@m.</span>ity@<span class="obfuscator">.nosp@m.</span>netwo<span class="obfuscator">.nosp@m.</span>rk-s<span class="obfuscator">.nosp@m.</span>ystem<span class="obfuscator">.nosp@m.</span>.dev</a>   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md523"></a>
개발 타임라인</h3>
<ul>
<li><b>Phase 1</b>: messaging_system으로부터 초기 분리</li>
<li><b>Phase 2</b>: 성능 최적화 및 벤치마킹</li>
<li><b>Phase 3</b>: 크로스 플랫폼 호환성 검증</li>
<li><b>Phase 4</b>: 생태계 통합 완료</li>
</ul>
<h2><a class="anchor" id="autotoc_md524"></a>
프로덕션 품질 및 아키텍처</h2>
<h3><a class="anchor" id="autotoc_md525"></a>
빌드 및 테스팅 인프라</h3>
<p><b>포괄적인 멀티 플랫폼 CI/CD</b></p><ul>
<li><b>Sanitizer 커버리지</b>: ThreadSanitizer, AddressSanitizer 및 UBSanitizer를 사용한 자동화된 빌드</li>
<li><b>멀티 플랫폼 테스팅</b>: Ubuntu (GCC/Clang), Windows (MSVC/MinGW) 및 macOS 전반에 걸친 지속적인 검증</li>
<li><b>성능 게이트</b>: 처리량 및 지연시간에 대한 회귀 감지</li>
<li><b>정적 분석</b>: modernize 검사를 포함한 Clang-tidy 및 Cppcheck 통합</li>
<li><b>자동화된 테스팅</b>: 커버리지 보고서를 포함한 완전한 CI/CD 파이프라인</li>
</ul>
<p><b>성능 기준선</b></p><ul>
<li><b>평균 처리량</b>: 초당 305,255 메시지 (혼합 워크로드)</li>
<li><b>최고 성능</b>: 64바이트 메시지에 대해 초당 769,230 메시지</li>
<li><b>동시 성능</b>: 50개 연결에서 초당 12,195 메시지 안정적</li>
<li><b>지연시간</b>: P50 &lt;50 μs, P95 &lt;500 μs, 평균 584 μs</li>
<li>**연결 설정**: 연결당 &lt;100 μs</li>
<li>**메모리 효율성**: 선형 확장으로 &lt;10 MB 기준선</li>
</ul>
<p>포괄적인 성능 메트릭 및 벤치마킹 세부 정보는 [BASELINE.md](BASELINE.md)를 참조하세요.</p>
<p>**완전한 문서 suite**</p><ul>
<li>[ARCHITECTURE.md](docs/ARCHITECTURE.md): Network system 설계 및 패턴</li>
<li>[INTEGRATION.md](docs/INTEGRATION.md): 생태계 통합 가이드</li>
<li>[MIGRATION_GUIDE.md](docs/MIGRATION_GUIDE.md): messaging_system으로부터 마이그레이션</li>
<li>[BASELINE.md](BASELINE.md): 성능 기준선 측정값</li>
</ul>
<h3><a class="anchor" id="autotoc_md526"></a>
Thread 안전성 및 동시성</h3>
<p>**프로덕션급 Thread 안전성 (100% 완료)**</p><ul>
<li>**멀티스레드 처리**: 동시 session 처리를 갖춘 thread-safe 메시지 처리</li>
<li>**ThreadSanitizer 준수**: 모든 테스트 시나리오에서 제로 데이터 경합 감지</li>
<li>**Session 관리**: 적절한 동기화를 통한 동시 session 수명 주기 처리</li>
<li>**Lock-Free Pipeline**: 최대 처리량을 위한 zero-copy 메시지 pipeline 구현</li>
</ul>
<p>**비동기 I/O 우수성**</p><ul>
<li>**ASIO 기반 아키텍처**: 입증된 ASIO 라이브러리를 사용한 고성능 비동기 I/O</li>
<li>**C++20 Coroutine**: 깨끗하고 효율적인 코드를 위한 coroutine 기반 비동기 작업</li>
<li>**Connection Pooling**: 지능적인 연결 재사용 및 수명 주기 관리</li>
<li>**이벤트 기반**: 최적의 리소스 활용을 위한 논블로킹 이벤트 루프 아키텍처</li>
</ul>
<h3><a class="anchor" id="autotoc_md527"></a>
리소스 관리 (RAII - Grade A)</h3>
<p>**포괄적인 RAII 준수**</p><ul>
<li>**100% 스마트 포인터 사용**: 모든 리소스는 `std::shared_ptr` 및 `std::unique_ptr`을 통해 관리됨</li>
<li>**AddressSanitizer 검증**: 모든 테스트 시나리오에서 제로 메모리 누수 감지</li>
<li>**RAII 패턴**: 연결 수명 주기 래퍼, session 관리, socket RAII 래퍼</li>
<li>**자동 정리**: 네트워크 연결, 비동기 작업 및 버퍼 리소스가 적절하게 관리됨</li>
<li>**수동 메모리 관리 없음**: public 인터페이스에서 원시 포인터 완전 제거</li>
</ul>
<p>**메모리 효율성 및 확장성** </p><div class="fragment"><div class="line"># AddressSanitizer: Clean across all tests</div>
<div class="line">==12345==ERROR: LeakSanitizer: detected memory leaks</div>
<div class="line"># Total: 0 leaks</div>
<div class="line"> </div>
<div class="line"># Memory scaling characteristics:</div>
<div class="line">Baseline: &lt;10 MB</div>
<div class="line">Per-connection overhead: Linear scaling</div>
<div class="line">Zero-copy pipeline: Minimizes allocations</div>
<div class="line">Resource cleanup: All connections RAII-managed</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md528"></a>
오류 처리 (핵심 API 마이그레이션 완료 - 75-80% 완료)</h3>
<p>**최신 업데이트 (2025-10-10)**: 핵심 API Result&lt;T&gt; 마이그레이션이 성공적으로 완료되었습니다! 이제 모든 주요 네트워킹 API가 포괄적인 오류 코드 및 type-safe 오류 처리와 함께 Result&lt;T&gt;를 반환합니다.</p>
<p><b>Result&lt;T&gt; 핵심 API - 프로덕션 준비 완료</b></p>
<p>network_system은 Phase 3 핵심 API를 Result&lt;T&gt; 패턴으로 마이그레이션을 완료했으며, 이제 모든 주요 네트워킹 API가 type-safe 오류 처리를 제공합니다:</p>
<p><b>완료된 작업 (2025-10-10)</b></p><ul>
<li>✅ <b>핵심 API 마이그레이션</b>: 모든 주요 네트워킹 API가 Result&lt;T&gt;로 마이그레이션됨<ul>
<li><code>messaging_server::start_server()</code>: <code>void</code> → <code>VoidResult</code></li>
<li><code>messaging_server::stop_server()</code>: <code>void</code> → <code>VoidResult</code></li>
<li><code>messaging_client::start_client()</code>: <code>void</code> → <code>VoidResult</code></li>
<li><code>messaging_client::stop_client()</code>: <code>void</code> → <code>VoidResult</code></li>
<li><code>messaging_client::send_packet()</code>: <code>void</code> → <code>VoidResult</code></li>
</ul>
</li>
<li>✅ <b>Result&lt;T&gt; Type System</b>: <code>result_types.h</code>에서 완전한 이중 API 구현<ul>
<li>Common system 통합 지원 (<code>#ifdef BUILD_WITH_COMMON_SYSTEM</code>)</li>
<li>독립적인 사용을 위한 독립형 대체 구현</li>
<li>헬퍼 함수: <code>ok()</code>, <code>error()</code>, <code>error_void()</code></li>
</ul>
</li>
<li>✅ <b>Error Code Registry</b>: 완전한 오류 코드 (-600 ~ -699) 정의<ul>
<li>Connection 오류 (-600 ~ -619): <code>connection_failed</code>, <code>connection_refused</code>, <code>connection_timeout</code>, <code>connection_closed</code></li>
<li>Session 오류 (-620 ~ -639): <code>session_not_found</code>, <code>session_expired</code>, <code>invalid_session</code></li>
<li>Send/Receive 오류 (-640 ~ -659): <code>send_failed</code>, <code>receive_failed</code>, <code>message_too_large</code></li>
<li>Server 오류 (-660 ~ -679): <code>server_not_started</code>, <code>server_already_running</code>, <code>bind_failed</code></li>
</ul>
</li>
<li>✅ <b>ASIO 오류 처리</b>: 향상된 크로스 플랫폼 오류 감지<ul>
<li><code>asio::error</code> 및 <code>std::errc</code> 카테고리 모두 확인</li>
<li>모든 ASIO 작업에 대한 적절한 오류 코드 매핑</li>
</ul>
</li>
<li>✅ <b>테스트 커버리지</b>: 모든 12개 단위 테스트가 마이그레이션되어 통과<ul>
<li>Exception 기반 assertion → Result&lt;T&gt; 검사</li>
<li>명시적 오류 코드 검증</li>
<li>모든 sanitizer 전반에 걸쳐 100% 테스트 성공률</li>
</ul>
</li>
</ul>
<p><b>현재 API 패턴 (프로덕션 준비 완료)</b> </p><div class="fragment"><div class="line"><span class="comment">// ✅ Migrated: Result&lt;T&gt; return values for type-safe error handling</span></div>
<div class="line"><span class="keyword">auto</span> start_server(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> port) -&gt; VoidResult;</div>
<div class="line"><span class="keyword">auto</span> stop_server() -&gt; VoidResult;</div>
<div class="line"><span class="keyword">auto</span> start_client(std::string_view host, <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> port) -&gt; VoidResult;</div>
<div class="line"><span class="keyword">auto</span> send_packet(std::vector&lt;uint8_t&gt; data) -&gt; VoidResult;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Usage example with Result&lt;T&gt;</span></div>
<div class="line"><span class="keyword">auto</span> result = server-&gt;start_server(8080);</div>
<div class="line"><span class="keywordflow">if</span> (result.is_err()) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Failed to start server: &quot;</span> &lt;&lt; result.error().message</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot; (code: &quot;</span> &lt;&lt; result.error().code &lt;&lt; <span class="stringliteral">&quot;)\n&quot;</span>;</div>
<div class="line">    <span class="keywordflow">return</span> -1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Async operations still use callbacks for completion events</span></div>
<div class="line"><span class="keyword">auto</span> on_receive(<span class="keyword">const</span> std::vector&lt;uint8_t&gt;&amp; data) -&gt; void;</div>
<div class="line"><span class="keyword">auto</span> on_error(std::error_code ec) -&gt; void;</div>
</div><!-- fragment --><p><b>레거시 API 패턴 (마이그레이션 전)</b> </p><div class="fragment"><div class="line"><span class="comment">// Old: void/callback-based error handling (no longer used)</span></div>
<div class="line"><span class="keyword">auto</span> start_server(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> port) -&gt; void;</div>
<div class="line"><span class="keyword">auto</span> stop_server() -&gt; void;</div>
<div class="line"><span class="keyword">auto</span> start_client(std::string_view host, <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> port) -&gt; void;</div>
<div class="line"><span class="keyword">auto</span> send_packet(std::vector&lt;uint8_t&gt; data) -&gt; void;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// All errors were handled via callbacks only</span></div>
<div class="line"><span class="keyword">auto</span> on_error(std::error_code ec) -&gt; void;</div>
</div><!-- fragment --><p><b>이중 API 구현</b> </p><div class="fragment"><div class="line"><span class="comment">// Supports both common_system integration and standalone usage</span></div>
<div class="line"><span class="preprocessor">#ifdef BUILD_WITH_COMMON_SYSTEM</span></div>
<div class="line">    <span class="comment">// Uses common_system Result&lt;T&gt; when available</span></div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">    <span class="keyword">using </span>Result = ::common::Result&lt;T&gt;;</div>
<div class="line">    <span class="keyword">using </span>VoidResult = ::common::VoidResult;</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">    <span class="comment">// Standalone fallback implementation</span></div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">    <span class="keyword">class </span>Result {</div>
<div class="line">        <span class="comment">// ... full implementation in result_types.h</span></div>
<div class="line">    };</div>
<div class="line">    <span class="keyword">using </span>VoidResult = Result&lt;std::monostate&gt;;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Helper functions available in both modes</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">inline</span> Result&lt;T&gt; ok(T&amp;&amp; value);</div>
<div class="line"><span class="keyword">inline</span> VoidResult ok();</div>
<div class="line"><span class="keyword">inline</span> VoidResult error_void(<span class="keywordtype">int</span> code, <span class="keyword">const</span> std::string&amp; message, ...);</div>
</div><!-- fragment --><p><b>남은 마이그레이션 작업</b> (20-25% 남음)</p><ul>
<li>🔲 <b>예제 업데이트</b>: Result&lt;T&gt; 사용법을 시연하도록 예제 코드 마이그레이션<ul>
<li>Result&lt;T&gt; 예제로 <code>samples/</code> 디렉토리 업데이트</li>
<li>오류 처리 시연 예제 생성</li>
</ul>
</li>
<li>🔲 <b>문서 업데이트</b>: Result&lt;T&gt; API에 대한 포괄적인 문서<ul>
<li>Result&lt;T&gt; 반환 타입으로 API 참조 업데이트</li>
<li>이전 API에서 업그레이드하는 사용자를 위한 마이그레이션 가이드 생성</li>
</ul>
</li>
<li>🔲 <b>Session 관리</b>: session 수명 주기 작업으로 Result&lt;T&gt; 확장<ul>
<li>Session 생성/소멸 Result&lt;T&gt; API</li>
<li>Session 상태 관리 오류 처리</li>
</ul>
</li>
<li>🔲 <b>비동기 변형</b> (향후): 네트워크 작업을 위한 비동기 Result&lt;T&gt; 변형 고려<ul>
<li>성능 영향 평가</li>
<li>비동기 호환 Result&lt;T&gt; 패턴 설계</li>
</ul>
</li>
</ul>
<p><b>Error Code 통합</b></p><ul>
<li><b>할당된 범위</b>: 중앙화된 오류 코드 레지스트리 (common_system)에서 <code>-600</code> ~ <code>-699</code></li>
<li><b>분류</b>: Connection (-600 ~ -619), Session (-620 ~ -639), Send/Receive (-640 ~ -659), Server (-660 ~ -679)</li>
<li><b>크로스 플랫폼</b>: ASIO 및 표준 라이브러리 오류 코드 모두와 호환되는 ASIO 오류 감지</li>
</ul>
<p><b>성능 검증</b>: 핵심 API 마이그레이션은 <b>초당 305K+ 메시지</b> 평균 처리량과 **&lt;50μs P50 지연시간**을 유지하며, Result&lt;T&gt; 패턴이 성능 저하 없이 type-safety를 추가함을 증명합니다.</p>
<p><b>향후 개선 사항</b></p><ul>
<li>📝 <b>고급 기능</b>: WebSocket 지원, TLS/SSL 암호화, HTTP/2 client, gRPC 통합</li>
<li>📝 <b>성능 최적화</b>: 고급 zero-copy 기술, NUMA 인식 thread pinning, 하드웨어 가속, 사용자 정의 메모리 할당자</li>
</ul>
<p>자세한 개선 계획 및 추적은 프로젝트의 NEED_TO_FIX.md를 참조하세요.</p>
<h3><a class="anchor" id="autotoc_md529"></a>
아키텍처 개선 단계</h3>
<p><b>Phase 상태 개요</b> (2025-10-10 기준):</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Phase   </th><th class="markdownTableHeadNone">상태   </th><th class="markdownTableHeadNone">완료도   </th><th class="markdownTableHeadNone">주요 성과    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Phase 0</b>: Foundation   </td><td class="markdownTableBodyNone">✅ 완료   </td><td class="markdownTableBodyNone">100%   </td><td class="markdownTableBodyNone">CI/CD 파이프라인, 기준선 메트릭, 테스트 커버리지    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Phase 1</b>: Thread 안전성   </td><td class="markdownTableBodyNone">✅ 완료   </td><td class="markdownTableBodyNone">100%   </td><td class="markdownTableBodyNone">ThreadSanitizer 검증, 동시 session 처리    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Phase 2</b>: 리소스 관리   </td><td class="markdownTableBodyNone">✅ 완료   </td><td class="markdownTableBodyNone">100%   </td><td class="markdownTableBodyNone">Grade A RAII, AddressSanitizer clean    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Phase 3</b>: 오류 처리   </td><td class="markdownTableBodyNone">🔄 진행 중   </td><td class="markdownTableBodyNone">75-80%   </td><td class="markdownTableBodyNone"><b>핵심 API 마이그레이션 완료</b> - Result&lt;T&gt;를 갖춘 5개 주요 API, 모든 테스트 통과    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Phase 4</b>: 성능   </td><td class="markdownTableBodyNone">⏳ 계획됨   </td><td class="markdownTableBodyNone">0%   </td><td class="markdownTableBodyNone">고급 zero-copy, NUMA 인식 thread pinning    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Phase 5</b>: 안정성   </td><td class="markdownTableBodyNone">⏳ 계획됨   </td><td class="markdownTableBodyNone">0%   </td><td class="markdownTableBodyNone">API 안정화, semantic versioning    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Phase 6</b>: 문서   </td><td class="markdownTableBodyNone">⏳ 계획됨   </td><td class="markdownTableBodyNone">0%   </td><td class="markdownTableBodyNone">포괄적인 가이드, 튜토리얼, 예제   </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md530"></a>
Phase 3: 오류 처리 (75-80% 완료) - 핵심 API 마이그레이션 완료 ✅</h4>
<p><b>최신 성과 (2025-10-10)</b>: 핵심 API Result&lt;T&gt; 마이그레이션이 성공적으로 완료되었습니다! 이제 모든 5개 주요 네트워킹 API가 포괄적인 오류 코드 및 type-safe 오류 처리와 함께 Result&lt;T&gt;를 반환합니다.</p>
<p><b>완료된 마일스톤</b>:</p><ol type="1">
<li>✅ <b>핵심 API 마이그레이션</b> (완료): 모든 5개 주요 API가 VoidResult로 마이그레이션됨<ul>
<li><code>messaging_server::start_server()</code>, <code>stop_server()</code></li>
<li><code>messaging_client::start_client()</code>, <code>stop_client()</code>, <code>send_packet()</code></li>
</ul>
</li>
<li>✅ <b>Result&lt;T&gt; Type System</b> (완료): <code>result_types.h</code>에서 전체 이중 API 구현</li>
<li>✅ <b>Error Code Registry</b> (완료): 오류 코드 -600 ~ -699 정의 및 통합</li>
<li>✅ <b>ASIO 오류 처리</b> (향상됨): ASIO 및 std::errc 모두에 대한 크로스 플랫폼 오류 감지</li>
<li>✅ <b>테스트 커버리지</b> (완료): 모든 12개 단위 테스트가 마이그레이션되어 100% 성공률로 통과</li>
</ol>
<p><b>현재 API 패턴</b> (프로덕션 준비 완료): </p><div class="fragment"><div class="line"><span class="comment">// ✅ All primary APIs now return VoidResult</span></div>
<div class="line"><span class="keyword">auto</span> start_server(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> port) -&gt; VoidResult;</div>
<div class="line"><span class="keyword">auto</span> stop_server() -&gt; VoidResult;</div>
<div class="line"><span class="keyword">auto</span> start_client(std::string_view host, <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> port) -&gt; VoidResult;</div>
<div class="line"><span class="keyword">auto</span> send_packet(std::vector&lt;uint8_t&gt; data) -&gt; VoidResult;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Usage with Result&lt;T&gt; pattern</span></div>
<div class="line"><span class="keyword">auto</span> result = server-&gt;start_server(8080);</div>
<div class="line"><span class="keywordflow">if</span> (result.is_err()) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Server start failed: &quot;</span> &lt;&lt; result.error().message &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">    <span class="keywordflow">return</span> -1;</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Error Code 커버리지</b>:</p><ul>
<li><b>-600 ~ -619</b>: Connection 오류 (<code>connection_failed</code>, <code>connection_refused</code>, <code>connection_timeout</code>, <code>connection_closed</code>)</li>
<li><b>-620 ~ -639</b>: Session 오류 (<code>session_not_found</code>, <code>session_expired</code>, <code>invalid_session</code>)</li>
<li><b>-640 ~ -659</b>: Send/Receive 오류 (<code>send_failed</code>, <code>receive_failed</code>, <code>message_too_large</code>)</li>
<li><b>-660 ~ -679</b>: Server 오류 (<code>server_not_started</code>, <code>server_already_running</code>, <code>bind_failed</code>)</li>
</ul>
<p><b>성능 검증</b>: 마이그레이션은 <b>초당 305K+ 메시지</b> 평균 처리량과 **&lt;50μs P50 지연시간**을 유지하며, Result&lt;T&gt;가 성능 저하 없이 type-safety를 추가함을 증명합니다.</p>
<p><b>남은 작업</b> (20-25%):</p><ul>
<li>🔲 Result&lt;T&gt; 사용 패턴을 시연하도록 예제 업데이트</li>
<li>🔲 Result&lt;T&gt;로 session 관리 API 확장</li>
<li>🔲 Result&lt;T&gt; 반환 타입으로 API 참조 문서 완료</li>
<li>🔲 향후 개선을 위한 비동기 Result&lt;T&gt; 변형 고려</li>
</ul>
<p>자세한 Phase 3 상태 및 히스토리는 PHASE_3_PREPARATION.md를 참조하세요.</p>
<hr  />
<div align="center"></div><div align="center"><b>🚀 Network System - 최신 C++을 위한 고성능 비동기 네트워킹</b></div><div align="center"><em>C++20 생태계를 위해 ❤️로 제작 | 프로덕션 준비 완료 | 엔터프라이즈급</em></div><div align="center"><a href="README.md#performance-benchmarks"><img src="https://img.shields.io/badge/Performance-305K%2B%20msg%2Fs-brightgreen.svg" alt="Performance" style="pointer-events: none;" class="inline"/></a> <a href="https://en.cppreference.com/w/cpp/20"><img src="https://img.shields.io/badge/C%2B%2B-20-blue.svg" alt="C++20" style="pointer-events: none;" class="inline"/></a> <a href="README.md#platform-support"><img src="https://img.shields.io/badge/Platform-Windows%20%7C%20Linux%20%7C%20macOS-lightgrey.svg" alt="Cross Platform" style="pointer-events: none;" class="inline"/></a></div><div align="center"><em>초고속 엔터프라이즈급 솔루션으로 네트워킹 아키텍처를 변환하세요</em></div><div align="center"></div> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
